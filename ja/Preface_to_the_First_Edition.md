# 第一版~序文

> コンピュータはバイオリンのようなものです。次のような場面を想像してみてください。ある初心者の人が、まず蓄音機を動かしてみて、それから次にバイオリンを触ってみます。その人は、バイオリンの音はひどいと言います。人間主義者たちや多くの計算機科学者から私たちが聞く話はそういったものです。コンピュータのプログラムは特定の目的にはよいが、柔軟ではないと。バイオリンやタイプライターだってそんなものです。使い方を学ばなければの話ですが。
> 
> ---Marvin Minsky, “Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas”

“The Structure and Interpretation of Computer Programs”(SICP, 計算機プログラムの構造と解釈)はマサチューセッツ工科大学(MIT)での入門者レベルの計算機科学の科目です。<abbr title="MIT">MIT</abbr>で電気工学や計算機工学を専攻する学生はすべて、4つある“共通コアカリキュラム”のひとつとして履修しなければなりません。残りは、回路と線形システムについての科目2つと、デジタルシステム設計の科目ひとつです。私たちは、この科目の開発に1978年から携わってきました。そして、1980年の秋からは、この教材の現在の形で毎年600人から700人の学生を教えてきています。ほとんどの学生はコンピュータについてそれまでまったく秩序立ったトレーニングを受けていないか、受けていてもわずかなものでした。とはいえ、コンピュータでちょっと遊んだことのある学生は多くいましたし、プログラミングやハードウェア設計に相当な経験のある学生も数人はいましたが。

私たちがこの計算機科学の入門科目の授業計画を策定するにあたって、二つの懸念点を内容に反映させました。一つ目は、コンピュータ言語はただコンピュータに操作を実行させる方法であるにとどまらず、方法論についての考え方を表現するための今までにない形式的媒体であるという考え方を打ち立てたいということでした。ですから、プログラムは人間が読めるように書かなくてはならず、それがたまたま機械によって実行できるというだけのことです。二つ目は、私たちがこのレベルの科目で扱われるべき中心的な題材について信じていることです。教えるべきはことは、特定のプログラミング言語の文法ではなく、また特定の関数を計算するための賢いアルゴリズムでもなく、さらに言うとアルゴリズムの数学的解析やコンピューティングの基礎ですらなく、重要なのは大きなソフトウェアシステムの知的複雑性をコントロールする技術であるということです。

私たちの目標は、この科目を修了した学生たちが、プログラミングのスタイルと美学について、基礎的な感覚を十分に身につけてくれることです。学生たちが、大きなシステムの複雑性をコントロールするための主要な技術を使いこなせるようになること。模範的なスタイルで書かれていれば、50ページにわたるプログラムでも読めるようになっていること。どんなときにも、何を読むべきでないか、何を理解しないでもいいかを判断できるようになること。また、プログラムを変更するにあたって、自信を持って、元の作者の意図とスタイルを保ったままで変更を加えることができるようになっていること。

これらのスキルは、決してコンピュータプログラミングに特有のものではありません。私たちが教え、また利用する技術は、すべての工学的設計に共通するものです。私たちは、詳細な部分を隠す抽象化を適宜加えることによって、複雑性をコントロールします。私たちは、共通のインターフェイスを確立し、標準的かつ中身のよくわかっている部品を「うまく組み合わせる」やり方で、複雑性をコントロールします。私たちは、設計を記述するためにさまざまな言語を作り出し、それぞれの言語が設計のある特定の側面を際立たせ、それ以外の側面を目立たなくさせることによって、複雑性をコントロールします。

私たちのこの科目に対するアプローチの底にあるものは、“計算機科学”は科学ではなく、その意義はコンピュータとほとんど関係がないという信念です。コンピュータ革命とは、私たちの考え方と、考えを表現するやり方の革命です。この変化を象徴する出来事は、**手続き的認識論**(_procedural epistemology_)---古典的な数学的テーマで取られるような宣言的な見方ではなく、命令的な見方による知識構造の研究---の出現でしょう。数学は、“何であるか”という考えについて正確に扱う枠組みを提供します。計算機科学は、“どうやるか”という考えについて正確に扱う枠組みを提供します。

この教材では、プログラミング言語Lispのひとつの方言を使います。言語を正式に教えることはしません。その必要がないからです。普通に使っていくだけで、数日のうちに学生は身につけます。これはLisp系の言語の大きな利点です。複合式を作るやり方は少ししかなく、構文構造はあってないようなものです。形式的な性質はすべて、チェスのルールのように、一時間もあればカバーできます。少ししたら、言語の構文的な詳細について忘れてしまい(元からそんなものはないので)、実際の問題---何を計算したいのか、どうやって問題を扱えるサイズの部品に分解するか、それらの部品をどのように作っていくか---に取り組むことになります。もうひとつのLispの利点は、私たちの知る限りほかのどんな言語よりも、プログラムをモジュールに分解する大規模な戦略をサポートしてくれる(しかし強制はしない)というところです。手続きやデータによる抽象化をしたり、よくある使い方のパターンを捉えるために高階関数を使ったり、代入とデータ変更によって局所状態をモデル化したり、ストリームと遅延評価によってプログラムの部品同士を連携させたりといったことが可能です。さらに、組み込み言語の実装も簡単にできます。また、これらすべては、漸進的なプログラム設計、構築、テスト、デバッグに対する優れたサポートを提供する対話的環境に埋め込まれています。これまでにないパワーと優美さを備えたすばらしいツールを作り上げたJohn McCarthyをはじめ、これまでのすべての世代のLispウィザードたちに感謝の気持ちを捧げます。

私たちが使うLispの方言であるSchemeは、LispとAlgolのパワーと優美さをひとつにまとめようとしたものです。Lispからは、シンプルな構文によるメタ言語的なパワー、プログラムをデータオブジェクトとして表す統一的なやり方、ガベージコレクションつきヒープへのデータ割り当てが取り込まれています。Algolからは、レキシカルスコープとブロック構造を取り込んでいます。これらは、Algol委員会のプログラミング言語設計の先駆者たちからの贈り物です。チャーチのλ計算とプログラミング言語の構造との間の関係についての洞察はJohn ReynoldsとPeter Landinによるものです。また、コンピュータが世界に現れる何十年も前からこの領域を探索してきた数学者たちに対する恩義も感じています。彼ら開拓者たちには、Alonzo Church, Barkley Rosser, Stephen Kleene, Haskell Curryなどが含まれます。
