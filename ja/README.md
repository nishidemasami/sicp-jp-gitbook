# 目次

* [目次](SUMMARY.md)
* [非公式Texinfoフォーマット](Unofficial_Texinfo_Format.md)
* [非公式日本語版](非公式日本語版.md)
* [非公式日本語版 翻訳改訂版](非公式日本語版_翻訳改訂版.md)
* [献辞](Dedication.md)
* [前書き](Foreword.md)
* [第二版~序文](Preface_to_the_Second_Edition.md)
* [第一版~序文](Preface_to_the_First_Edition.md)
* [謝辞](Acknowledgments.md)
* [1 手続きを用いた抽象化の構築](Building_Abstractions_with_Procedures.md)
  * [1.1 プログラミングの要素](The_Elements_of_Programming.md)
    * [1.1.1 式](Expressions.md)
    * [1.1.2 命名と環境](Naming_and_the_Environment.md)
    * [1.1.3 組み合わせの評価](Evaluating_Combinations.md)
    * [1.1.4 複合手続き](Compound_Procedures.md)
    * [1.1.5 手続き適用の置換モデル](The_Substitution_Model_for_Procedure_Application.md)
    * [1.1.6 条件式と述語](Conditional_Expressions_and_Predicates.md)
    * [1.1.7 例: ニュートン法による平方根](Example_Square_Roots_by_Newtons_Method.md)
    * [1.1.8 ブラックボックス抽象化としての手続き](Procedures_as_Black_Box_Abstractions.md)
  * [1.2 手続きとそれが生成するプロセス](Procedures_and_the_Processes_They_Generate.md)
    * [1.2.1 線形再帰と反復](Linear_Recursion_and_Iteration.md)
    * [1.2.2 木の再帰](Tree_Recursion.md)
    * [1.2.3 増加オーダー](Orders_of_Growth.md)
    * [1.2.4 指数計算](Exponentiation.md)
    * [1.2.5 最大公約数](Greatest_Common_Divisors.md)
    * [1.2.6 例: 素数判定](Example_Testing_for_Primality.md)
  * [1.3 高階手続きによる抽象の定式化](Formulating_Abstractions_with_Higher_Order_Procedures.md)
    * [1.3.1 引数としての手続き](Procedures_as_Arguments.md)
    * [1.3.2 \code{lambda}を使って手続きを構築する](Constructing_Procedures_Using_lambda.md)
    * [1.3.3 汎用手法としての手続き](Procedures_as_General_Methods.md)
    * [1.3.4 返り値としての手続き](Procedures_as_Returned_Values.md)
* [2 データを用いた抽象化の構築](Building_Abstractions_with_Data.md)
  * [2.1 データ抽象化入門](Introduction_to_Data_Abstraction.md)
    * [2.1.1 例: 有理数の数値演算](Example_Arithmetic_Operations_for_Rational_Numbers.md)
    * [2.1.2 抽象化の壁](Abstraction_Barriers.md)
    * [2.1.3 データとは何か](What_Is_Meant_by_Data.md)
    * [2.1.4 発展問題: 区間演算](Extended_Exercise_Interval_Arithmetic.md)
  * [2.2 階層データと閉包性](Hierarchical_Data_and_the_Closure_Property.md)
    * [2.2.1 列の表現](Representing_Sequences.md)
    * [2.2.2 階層構造](Hierarchical_Structures.md)
    * [2.2.3 標準インターフェイスとしての列](Sequences_as_Conventional_Interfaces.md)
    * [2.2.4 例: 図形言語](Example_A_Picture_Language.md)
  * [2.3 記号データ](Symbolic_Data.md)
    * [2.3.1 クォート](Quotation.md)
    * [2.3.2 例: 記号微分](Example_Symbolic_Differentiation.md)
    * [2.3.3 例: 集合を表現する](Example_Representing_Sets.md)
    * [2.3.4 例: ハフマン符号化木](Example_Huffman_Encoding_Trees.md)
  * [2.4 抽象データの多重表現](Multiple_Representations_for_Abstract_Data.md)
    * [2.4.1 複素数の表現](Representations_for_Complex_Numbers.md)
    * [2.4.2 タグつきデータ](Tagged_data.md)
    * [2.4.3 データ主導プログラミングと加法性](Data_Directed_Programming_and_Additivity.md)
  * [2.5 ジェネリック演算によるシステム](Systems_with_Generic_Operations.md)
    * [2.5.1 ジェネリック算術演算](Generic_Arithmetic_Operations.md)
    * [2.5.2 異なる型のデータを組み合わせる](Combining_Data_of_Different_Types.md)
    * [2.5.3 例: 記号代数](Example_Symbolic_Algebra.md)
* [3 モジュール性、オブジェクト、状態](Modularity_Objects_and_State.md)
  * [3.1 代入と局所状態](Assignment_and_Local_State.md)
    * [3.1.1 局所状態変数](Local_State_Variables.md)
    * [3.1.2 代入を導入する利点](The_Benefits_of_Introducing_Assignment.md)
    * [3.1.3 代入を導入することのコスト](The_Costs_of_Introducing_Assignment.md)
  * [3.2 評価の環境モデル](The_Environment_Model_of_Evaluation.md)
    * [3.2.1 評価規則](The_Rules_for_Evaluation.md)
    * [3.2.2 単純な手続きの適用](Applying_Simple_Procedures.md)
    * [3.2.3 局所状態の保管場所としてのフレーム](Frames_as_the_Repository_of_Local_State.md)
    * [3.2.4 内部定義](Internal_Definitions.md)
  * [3.3 可変データによるモデル化](Modeling_with_Mutable_Data.md)
    * [3.3.1 可変リスト構造](Mutable_List_Structure.md)
    * [3.3.2 キューの表現](Representing_Queues.md)
    * [3.3.3 テーブルの表現](Representing_Tables.md)
    * [3.3.4 デジタル回路シミュレータ](A_Simulator_for_Digital_Circuits.md)
    * [3.3.5 制約伝播](Propagation_of_Constraints.md)
  * [3.4 並行性: 期限厳守](Concurrency_Time_Is_of_the_Essence.md)
    * [3.4.1 並行システムにおける時間の性質](The_Nature_of_Time_in_Concurrent_Systems.md)
    * [3.4.2 並行性制御メカニズム](Mechanisms_for_Controlling_Concurrency.md)
  * [3.5 ストリーム](Streams.md)
    * [3.5.1 ストリーム＝遅延リスト](Streams_Are_Delayed_Lists.md)
    * [3.5.2 無限ストリーム](Infinite_Streams.md)
    * [3.5.3 ストリームパラダイムの活用](Exploiting_the_Stream_Paradigm.md)
    * [3.5.4 ストリームと遅延評価](Streams_and_Delayed_Evaluation.md)
    * [3.5.5 関数型プログラムのモジュール性とオブジェクトのモジュール性](Modularity_of_Functional_Programs_and_Modularity_of_Objects.md)
* [4 メタ言語抽象化](Metalinguistic_Abstraction.md)
  * [4.1 メタ循環評価器](The_Metacircular_Evaluator.md)
    * [4.1.1 評価器のコア](The_Core_of_the_Evaluator.md)
    * [4.1.2 式の表現](Representing_Expressions.md)
    * [4.1.3 評価器のデータ構造](評価器のEvaluator_Data_Structuresデータ構造.md)
    * [4.1.4 評価器をプログラムとして実行する](Running_the_Evaluator_as_a_Program.md)
    * [4.1.5 プログラムとしてのデータ](Data_as_Programs.md)
    * [4.1.6 内部定義](内部定Internal_Definitions義.md)
    * [4.1.7 構文解析を実行から分離する](Separating_Syntactic_Analysis_from_Execution.md)
  * [4.2 Schemeの変異版 --- 遅延評価](Variations_on_a_Scheme_Lazy_Evaluation.md)
    * [4.2.1 正規順序と適用順序](Normal_Order_and_Applicative_Order.md)
    * [4.2.2 遅延評価のインタプリタ](An_Interpreter_with_Lazy_Evaluation.md)
    * [4.2.3 遅延化リストとしてのストリーム](Streams_as_Lazy_Lists.md)
  * [4.3 Schemeの変異版 --- 非決定性計算](Variations_on_a_Scheme_Nondeterministic_Computing.md)
    * [4.3.1 ambと探索](Amb_and_Search.md)
    * [4.3.2 非決定性プログラムの例](Examples_of_Nondeterministic_Programs.md)
    * [4.3.3 \code{amb}評価器の実装](Implementing_the_amb_Evaluator.md)
  * [4.4 論理プログラミング](Logic_Programming.md)
    * [4.4.1 推論的情報検索](Deductive_Information_Retrieval.md)
    * [4.4.2 クエリシステムの仕組み](How_the_Query_System_Works.md)
    * [4.4.3 論理プログラミングは数学論理学か](Is_Logic_Programming_Mathematical_Logic.md)
    * [4.4.4 クエリシステムの実装](Implementing_the_Query_System.md)
      * [4.4.4.1 ドライバループと具体化](The_Driver_Loop_and_Instantiation.md)
      * [4.4.4.2 評価器](The_Evaluator.md)
      * [4.4.4.3 パターンマッチングによる表明の検索](Finding_Assertions_by_Pattern_Matching.md)
      * [4.4.4.4 規則とユニフィケーション](Rules_and_Unification.md)
      * [4.4.4.5 データベースの保守](Maintaining_the_Data_Base.md)
      * [4.4.4.6 ストリーム演算](Stream_Operations.md)
      * [4.4.4.7 クエリ構文手続き](Query_Syntax_Procedures.md)
      * [4.4.4.8 フレームと束縛](Frames_and_Bindings.md)
* [5 レジスタマシンによる計算](Computing_with_Register_Machines.md)
  * [5.1 レジスタマシンの設計](Designing_Register_Machines.md)
    * [5.1.1 レジスタマシンの記述言語](A_Language_for_Describing_Register_Machines.md)
    * [5.1.2 マシン設計における抽象化](Abstraction_in_Machine_Design.md)
    * [5.1.3 サブルーチン](Subroutines.md)
    * [5.1.4 再帰の実装にスタックを使う](Using_a_Stack_to_Implement_Recursion.md)
    * [5.1.5 命令まとめ](Instruction_Summary.md)
  * [5.2 レジスタマシンシミュレータ](A_Register_Machine_Simulator.md)
    * [5.2.1 マシンモデル](The_Machine_Model.md)
    * [5.2.2 アセンブラ](The_Assembler.md)
    * [5.2.3 命令の実行手続きの生成](Generating_Execution_Procedures_for_Instructions.md)
    * [5.2.4 マシンパフォーマンスの監視](Monitoring_Machine_Performance.md)
  * [5.3 記憶領域の割り当てとガベージコレクション](Storage_Allocation_and_Garbage_Collection.md)
    * [5.3.1 ベクタとしてのメモリ](Memory_as_Vectors.md)
    * [5.3.2 無限メモリ幻想の維持](Maintaining_the_Illusion_of_Infinite_Memory.md)
  * [5.4 明示制御評価器](The_Explicit_Control_Evaluator.md)
    * [5.4.1 明示制御評価器のコア](The_Core_of_the_Explicit_Control_Evaluator.md)
    * [5.4.2 列の評価と末尾再帰](Sequence_Evaluation_and_Tail_Recursion.md)
    * [5.4.3 条件文、代入、定義](Conditionals_Assignments_and_Definitions.md)
    * [5.4.4 評価器の実行](Running_the_Evaluator.md)
  * [5.5 コンパイル](Compilation.md)
    * [5.5.1 コンパイラの構造](Structure_of_the_Compiler.md)
    * [5.5.2 式のコンパイル](Compiling_Expressions.md)
    * [5.5.3 組み合わせのコンパイル](Compiling_Combinations.md)
    * [5.5.4 命令列のコンパイル](Combining_Instruction_Sequences.md)
    * [5.5.5 コンパイル済みコードの例](An_Example_of_Compiled_Code.md)
    * [5.5.6 レキシカルアドレッシング](Lexical_Addressing.md)
    * [5.5.7 コンパイル済みコードと評価器の接続](Interfacing_Compiled_Code_to_the_Evaluator.md)
* [参考文献](References.md)
* [練習問題リスト](List_of_Exercises.md)
* [図一覧](List_of_Figures.md)
* [索引](Index.md)
* [奥付](Colophon.md)