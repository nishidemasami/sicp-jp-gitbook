# 目次

* [目次](SUMMARY.md)
* [非公式Texinfoフォーマット](Unofficial_Texinfo_Format.md)
* [非公式日本語版](非公式日本語版.md)
* [非公式日本語版 翻訳改訂版](非公式日本語版_翻訳改訂版.md)
* [献辞](Dedication.md)
* [前書き](Foreword.md)
* [第二版~序文](Preface_to_the_Second_Edition.md)
* [第一版~序文](Preface_to_the_First_Edition.md)
* [謝辞](Acknowledgments.md)
* [1 手続きを用いた抽象化の構築](1_Building_Abstractions_with_Procedures.md)
  * [1.1 プログラミングの要素](1.1_The_Elements_of_Programming.md)
    * [1.1.1 式](1.1.1_Expressions.md)
    * [1.1.2 命名と環境](1.1.2_Naming_and_the_Environment.md)
    * [1.1.3 組み合わせの評価](1.1.3_Evaluating_Combinations.md)
    * [1.1.4 複合手続き](1.1.4_Compound_Procedures.md)
    * [1.1.5 手続き適用の置換モデル](1.1.5_The_Substitution_Model_for_Procedure_Application.md)
    * [1.1.6 条件式と述語](1.1.6_Conditional_Expressions_and_Predicates.md)
    * [1.1.7 例: ニュートン法による平方根](1.1.7_Example_Square_Roots_by_Newtons_Method.md)
    * [1.1.8 ブラックボックス抽象化としての手続き](1.1.8_Procedures_as_Black_Box_Abstractions.md)
  * [1.2 手続きとそれが生成するプロセス](1.2_Procedures_and_the_Processes_They_Generate.md)
    * [1.2.1 線形再帰と反復](1.2.1_Linear_Recursion_and_Iteration.md)
    * [1.2.2 木の再帰](1.2.2_Tree_Recursion.md)
    * [1.2.3 増加オーダー](1.2.3_Orders_of_Growth.md)
    * [1.2.4 指数計算](1.2.4_Exponentiation.md)
    * [1.2.5 最大公約数](1.2.5_Greatest_Common_Divisors.md)
    * [1.2.6 例: 素数判定](1.2.6_Example_Testing_for_Primality.md)
  * [1.3 高階手続きによる抽象の定式化](1.3_Formulating_Abstractions_with_Higher_Order_Procedures.md)
    * [1.3.1 引数としての手続き](1.3.1_Procedures_as_Arguments.md)
    * [1.3.2 \code{lambda}を使って手続きを構築する](1.3.2_Constructing_Procedures_Using_lambda.md)
    * [1.3.3 汎用手法としての手続き](1.3.3_Procedures_as_General_Methods.md)
    * [1.3.4 返り値としての手続き](1.3.4_Procedures_as_Returned_Values.md)
* [2 データを用いた抽象化の構築](2_Building_Abstractions_with_Data.md)
  * [2.1 データ抽象化入門](2.1_Introduction_to_Data_Abstraction.md)
    * [2.1.1 例: 有理数の数値演算](2.1.1_Example_Arithmetic_Operations_for_Rational_Numbers.md)
    * [2.1.2 抽象化の壁](2.1.2_Abstraction_Barriers.md)
    * [2.1.3 データとは何か](2.1.3_What_Is_Meant_by_Data.md)
    * [2.1.4 発展問題: 区間演算](2.1.4_Extended_Exercise_Interval_Arithmetic.md)
  * [2.2 階層データと閉包性](2.2_Hierarchical_Data_and_the_Closure_Property.md)
    * [2.2.1 列の表現](2.2.1_Representing_Sequences.md)
    * [2.2.2 階層構造](2.2.2_Hierarchical_Structures.md)
    * [2.2.3 標準インターフェイスとしての列](2.2.3_Sequences_as_Conventional_Interfaces.md)
    * [2.2.4 例: 図形言語](2.2.4_Example_A_Picture_Language.md)
  * [2.3 記号データ](2.3_Symbolic_Data.md)
    * [2.3.1 クォート](2.3.1_Quotation.md)
    * [2.3.2 例: 記号微分](2.3.2_Example_Symbolic_Differentiation.md)
    * [2.3.3 例: 集合を表現する](2.3.3_Example_Representing_Sets.md)
    * [2.3.4 例: ハフマン符号化木](2.3.4_Example_Huffman_Encoding_Trees.md)
  * [2.4 抽象データの多重表現](2.4_Multiple_Representations_for_Abstract_Data.md)
    * [2.4.1 複素数の表現](2.4.1_Representations_for_Complex_Numbers.md)
    * [2.4.2 タグつきデータ](2.4.2_Tagged_data.md)
    * [2.4.3 データ主導プログラミングと加法性](2.4.3_Data_Directed_Programming_and_Additivity.md)
  * [2.5 ジェネリック演算によるシステム](2.5_Systems_with_Generic_Operations.md)
    * [2.5.1 ジェネリック算術演算](2.5.1_Generic_Arithmetic_Operations.md)
    * [2.5.2 異なる型のデータを組み合わせる](2.5.2_Combining_Data_of_Different_Types.md)
    * [2.5.3 例: 記号代数](2.5.3_Example_Symbolic_Algebra.md)
* [3 モジュール性、オブジェクト、状態](3_Modularity_Objects_and_State.md)
  * [3.1 代入と局所状態](3.1_Assignment_and_Local_State.md)
    * [3.1.1 局所状態変数](3.1.1_Local_State_Variables.md)
    * [3.1.2 代入を導入する利点](3.1.2_The_Benefits_of_Introducing_Assignment.md)
    * [3.1.3 代入を導入することのコスト](3.1.3_The_Costs_of_Introducing_Assignment.md)
  * [3.2 評価の環境モデル](3.2_The_Environment_Model_of_Evaluation.md)
    * [3.2.1 評価規則](3.2.1_The_Rules_for_Evaluation.md)
    * [3.2.2 単純な手続きの適用](3.2.2_Applying_Simple_Procedures.md)
    * [3.2.3 局所状態の保管場所としてのフレーム](3.2.3_Frames_as_the_Repository_of_Local_State.md)
    * [3.2.4 内部定義](3.2.4_Internal_Definitions.md)
  * [3.3 可変データによるモデル化](3.3_Modeling_with_Mutable_Data.md)
    * [3.3.1 可変リスト構造](3.3.1_Mutable_List_Structure.md)
    * [3.3.2 キューの表現](3.3.2_Representing_Queues.md)
    * [3.3.3 テーブルの表現](3.3.3_Representing_Tables.md)
    * [3.3.4 デジタル回路シミュレータ](3.3.4_A_Simulator_for_Digital_Circuits.md)
    * [3.3.5 制約伝播](3.3.5_Propagation_of_Constraints.md)
  * [3.4 並行性: 期限厳守](3.4_Concurrency_Time_Is_of_the_Essence.md)
    * [3.4.1 並行システムにおける時間の性質](3.4.1_The_Nature_of_Time_in_Concurrent_Systems.md)
    * [3.4.2 並行性制御メカニズム](3.4.2_Mechanisms_for_Controlling_Concurrency.md)
  * [3.5 ストリーム](3.5_Streams.md)
    * [3.5.1 ストリーム＝遅延リスト](3.5.1_Streams_Are_Delayed_Lists.md)
    * [3.5.2 無限ストリーム](3.5.2_Infinite_Streams.md)
    * [3.5.3 ストリームパラダイムの活用](3.5.3_Exploiting_the_Stream_Paradigm.md)
    * [3.5.4 ストリームと遅延評価](3.5.4_Streams_and_Delayed_Evaluation.md)
    * [3.5.5 関数型プログラムのモジュール性とオブジェクトのモジュール性](3.5.5_Modularity_of_Functional_Programs_and_Modularity_of_Objects.md)
* [4 メタ言語抽象化](4_Metalinguistic_Abstraction.md)
  * [4.1 メタ循環評価器](4.1_The_Metacircular_Evaluator.md)
    * [4.1.1 評価器のコア](4.1.1_The_Core_of_the_Evaluator.md)
    * [4.1.2 式の表現](4.1.2_Representing_Expressions.md)
    * [4.1.3 評価器のデータ構造](4.1.3_評価器のEvaluator_Data_Structuresデータ構造.md)
    * [4.1.4 評価器をプログラムとして実行する](4.1.4_Running_the_Evaluator_as_a_Program.md)
    * [4.1.5 プログラムとしてのデータ](4.1.5_Data_as_Programs.md)
    * [4.1.6 内部定義](4.1.6_内部定Internal_Definitions義.md)
    * [4.1.7 構文解析を実行から分離する](4.1.7_Separating_Syntactic_Analysis_from_Execution.md)
  * [4.2 Schemeの変異版 --- 遅延評価](4.2_Variations_on_a_Scheme_Lazy_Evaluation.md)
    * [4.2.1 正規順序と適用順序](4.2.1_Normal_Order_and_Applicative_Order.md)
    * [4.2.2 遅延評価のインタプリタ](4.2.2_An_Interpreter_with_Lazy_Evaluation.md)
    * [4.2.3 遅延化リストとしてのストリーム](4.2.3_Streams_as_Lazy_Lists.md)
  * [4.3 Schemeの変異版 --- 非決定性計算](4.3_Variations_on_a_Scheme_Nondeterministic_Computing.md)
    * [4.3.1 ambと探索](4.3.1_Amb_and_Search.md)
    * [4.3.2 非決定性プログラムの例](4.3.2_Examples_of_Nondeterministic_Programs.md)
    * [4.3.3 \code{amb}評価器の実装](4.3.3_Implementing_the_amb_Evaluator.md)
  * [4.4 論理プログラミング](4.4_Logic_Programming.md)
    * [4.4.1 推論的情報検索](4.4.1_Deductive_Information_Retrieval.md)
    * [4.4.2 クエリシステムの仕組み](4.4.2_How_the_Query_System_Works.md)
    * [4.4.3 論理プログラミングは数学論理学か](4.4.3_Is_Logic_Programming_Mathematical_Logic.md)
    * [4.4.4 クエリシステムの実装](4.4.4_Implementing_the_Query_System.md)
      * [4.4.4.1 ドライバループと具体化](4.4.4.1_The_Driver_Loop_and_Instantiation.md)
      * [4.4.4.2 評価器](4.4.4.2_The_Evaluator.md)
      * [4.4.4.3 パターンマッチングによる表明の検索](4.4.4.3_Finding_Assertions_by_Pattern_Matching.md)
      * [4.4.4.4 規則とユニフィケーション](4.4.4.4_Rules_and_Unification.md)
      * [4.4.4.5 データベースの保守](4.4.4.5_Maintaining_the_Data_Base.md)
      * [4.4.4.6 ストリーム演算](4.4.4.6_Stream_Operations.md)
      * [4.4.4.7 クエリ構文手続き](4.4.4.7_Query_Syntax_Procedures.md)
      * [4.4.4.8 フレームと束縛](4.4.4.8_Frames_and_Bindings.md)
* [5 レジスタマシンによる計算](5_Computing_with_Register_Machines.md)
  * [5.1 レジスタマシンの設計](5.1_Designing_Register_Machines.md)
    * [5.1.1 レジスタマシンの記述言語](5.1.1_A_Language_for_Describing_Register_Machines.md)
    * [5.1.2 マシン設計における抽象化](5.1.2_Abstraction_in_Machine_Design.md)
    * [5.1.3 サブルーチン](5.1.3_Subroutines.md)
    * [5.1.4 再帰の実装にスタックを使う](5.1.4_Using_a_Stack_to_Implement_Recursion.md)
    * [5.1.5 命令まとめ](5.1.5_Instruction_Summary.md)
  * [5.2 レジスタマシンシミュレータ](5.2_A_Register_Machine_Simulator.md)
    * [5.2.1 マシンモデル](5.2.1_The_Machine_Model.md)
    * [5.2.2 アセンブラ](5.2.2_The_Assembler.md)
    * [5.2.3 命令の実行手続きの生成](5.2.3_Generating_Execution_Procedures_for_Instructions.md)
    * [5.2.4 マシンパフォーマンスの監視](5.2.4_Monitoring_Machine_Performance.md)
  * [5.3 記憶領域の割り当てとガベージコレクション](5.3_Storage_Allocation_and_Garbage_Collection.md)
    * [5.3.1 ベクタとしてのメモリ](5.3.1_Memory_as_Vectors.md)
    * [5.3.2 無限メモリ幻想の維持](5.3.2_Maintaining_the_Illusion_of_Infinite_Memory.md)
  * [5.4 明示制御評価器](5.4_The_Explicit_Control_Evaluator.md)
    * [5.4.1 明示制御評価器のコア](5.4.1_The_Core_of_the_Explicit_Control_Evaluator.md)
    * [5.4.2 列の評価と末尾再帰](5.4.2_Sequence_Evaluation_and_Tail_Recursion.md)
    * [5.4.3 条件文、代入、定義](5.4.3_Conditionals_Assignments_and_Definitions.md)
    * [5.4.4 評価器の実行](5.4.4_Running_the_Evaluator.md)
  * [5.5 コンパイル](5.5_Compilation.md)
    * [5.5.1 コンパイラの構造](5.5.1_Structure_of_the_Compiler.md)
    * [5.5.2 式のコンパイル](5.5.2_Compiling_Expressions.md)
    * [5.5.3 組み合わせのコンパイル](5.5.3_Compiling_Combinations.md)
    * [5.5.4 命令列のコンパイル](5.5.4_Combining_Instruction_Sequences.md)
    * [5.5.5 コンパイル済みコードの例](5.5.5_An_Example_of_Compiled_Code.md)
    * [5.5.6 レキシカルアドレッシング](5.5.6_Lexical_Addressing.md)
    * [5.5.7 コンパイル済みコードと評価器の接続](5.5.7_Interfacing_Compiled_Code_to_the_Evaluator.md)
* [参考文献](References.md)
* [練習問題リスト](List_of_Exercises.md)
* [図一覧](List_of_Figures.md)
* [索引](Index.md)
* [奥付](Colophon.md)