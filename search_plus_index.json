{"./":{"url":"./","title":"Introduction","keywords":"","body":"目次 目次 非公式Texinfoフォーマット 非公式日本語版 非公式日本語版 翻訳改訂版 献辞 前書き 第二版~序文 第一版~序文 謝辞 1 手続きを用いた抽象化の構築 1.1 プログラミングの要素 1.1.1 式 1.1.2 命名と環境 1.1.3 組み合わせの評価 1.1.4 複合手続き 1.1.5 手続き適用の置換モデル 1.1.6 条件式と述語 1.1.7 例: ニュートン法による平方根 1.1.8 ブラックボックス抽象化としての手続き 1.2 手続きとそれが生成するプロセス 1.2.1 線形再帰と反復 1.2.2 木の再帰 1.2.3 増加オーダー 1.2.4 指数計算 1.2.5 最大公約数 1.2.6 例: 素数判定 1.3 高階手続きによる抽象の定式化 1.3.1 引数としての手続き 1.3.2 \\code{lambda}を使って手続きを構築する 1.3.3 汎用手法としての手続き 1.3.4 返り値としての手続き 2 データを用いた抽象化の構築 2.1 データ抽象化入門 2.1.1 例: 有理数の数値演算 2.1.2 抽象化の壁 2.1.3 データとは何か 2.1.4 発展問題: 区間演算 2.2 階層データと閉包性 2.2.1 列の表現 2.2.2 階層構造 2.2.3 標準インターフェイスとしての列 2.2.4 例: 図形言語 2.3 記号データ 2.3.1 クォート 2.3.2 例: 記号微分 2.3.3 例: 集合を表現する 2.3.4 例: ハフマン符号化木 2.4 抽象データの多重表現 2.4.1 複素数の表現 2.4.2 タグつきデータ 2.4.3 データ主導プログラミングと加法性 2.5 ジェネリック演算によるシステム 2.5.1 ジェネリック算術演算 2.5.2 異なる型のデータを組み合わせる 2.5.3 例: 記号代数 3 モジュール性、オブジェクト、状態 3.1 代入と局所状態 3.1.1 局所状態変数 3.1.2 代入を導入する利点 3.1.3 代入を導入することのコスト 3.2 評価の環境モデル 3.2.1 評価規則 3.2.2 単純な手続きの適用 3.2.3 局所状態の保管場所としてのフレーム 3.2.4 内部定義 3.3 可変データによるモデル化 3.3.1 可変リスト構造 3.3.2 キューの表現 3.3.3 テーブルの表現 3.3.4 デジタル回路シミュレータ 3.3.5 制約伝播 3.4 並行性: 期限厳守 3.4.1 並行システムにおける時間の性質 3.4.2 並行性制御メカニズム 3.5 ストリーム 3.5.1 ストリーム＝遅延リスト 3.5.2 無限ストリーム 3.5.3 ストリームパラダイムの活用 3.5.4 ストリームと遅延評価 3.5.5 関数型プログラムのモジュール性とオブジェクトのモジュール性 4 メタ言語抽象化 4.1 メタ循環評価器 4.1.1 評価器のコア 4.1.2 式の表現 4.1.3 評価器のデータ構造 4.1.4 評価器をプログラムとして実行する 4.1.5 プログラムとしてのデータ 4.1.6 内部定義 4.1.7 構文解析を実行から分離する 4.2 Schemeの変異版 --- 遅延評価 4.2.1 正規順序と適用順序 4.2.2 遅延評価のインタプリタ 4.2.3 遅延化リストとしてのストリーム 4.3 Schemeの変異版 --- 非決定性計算 4.3.1 ambと探索 4.3.2 非決定性プログラムの例 4.3.3 \\code{amb}評価器の実装 4.4 論理プログラミング 4.4.1 推論的情報検索 4.4.2 クエリシステムの仕組み 4.4.3 論理プログラミングは数学論理学か 4.4.4 クエリシステムの実装 4.4.4.1 ドライバループと具体化 4.4.4.2 評価器 4.4.4.3 パターンマッチングによる表明の検索 4.4.4.4 規則とユニフィケーション 4.4.4.5 データベースの保守 4.4.4.6 ストリーム演算 4.4.4.7 クエリ構文手続き 4.4.4.8 フレームと束縛 5 レジスタマシンによる計算 5.1 レジスタマシンの設計 5.1.1 レジスタマシンの記述言語 5.1.2 マシン設計における抽象化 5.1.3 サブルーチン 5.1.4 再帰の実装にスタックを使う 5.1.5 命令まとめ 5.2 レジスタマシンシミュレータ 5.2.1 マシンモデル 5.2.2 アセンブラ 5.2.3 命令の実行手続きの生成 5.2.4 マシンパフォーマンスの監視 5.3 記憶領域の割り当てとガベージコレクション 5.3.1 ベクタとしてのメモリ 5.3.2 無限メモリ幻想の維持 5.4 明示制御評価器 5.4.1 明示制御評価器のコア 5.4.2 列の評価と末尾再帰 5.4.3 条件文、代入、定義 5.4.4 評価器の実行 5.5 コンパイル 5.5.1 コンパイラの構造 5.5.2 式のコンパイル 5.5.3 組み合わせのコンパイル 5.5.4 命令列のコンパイル 5.5.5 コンパイル済みコードの例 5.5.6 レキシカルアドレッシング 5.5.7 コンパイル済みコードと評価器の接続 参考文献 練習問題リスト 図一覧 索引 奥付 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目次","keywords":"","body":"目次 目次 非公式Texinfoフォーマット 非公式日本語版 非公式日本語版 翻訳改訂版 献辞 前書き 第二版~序文 第一版~序文 謝辞 1 手続きを用いた抽象化の構築 1.1 プログラミングの要素 1.1.1 式 1.1.2 命名と環境 1.1.3 組み合わせの評価 1.1.4 複合手続き 1.1.5 手続き適用の置換モデル 1.1.6 条件式と述語 1.1.7 例: ニュートン法による平方根 1.1.8 ブラックボックス抽象化としての手続き 1.2 手続きとそれが生成するプロセス 1.2.1 線形再帰と反復 1.2.2 木の再帰 1.2.3 増加オーダー 1.2.4 指数計算 1.2.5 最大公約数 1.2.6 例: 素数判定 1.3 高階手続きによる抽象の定式化 1.3.1 引数としての手続き 1.3.2 \\code{lambda}を使って手続きを構築する 1.3.3 汎用手法としての手続き 1.3.4 返り値としての手続き 2 データを用いた抽象化の構築 2.1 データ抽象化入門 2.1.1 例: 有理数の数値演算 2.1.2 抽象化の壁 2.1.3 データとは何か 2.1.4 発展問題: 区間演算 2.2 階層データと閉包性 2.2.1 列の表現 2.2.2 階層構造 2.2.3 標準インターフェイスとしての列 2.2.4 例: 図形言語 2.3 記号データ 2.3.1 クォート 2.3.2 例: 記号微分 2.3.3 例: 集合を表現する 2.3.4 例: ハフマン符号化木 2.4 抽象データの多重表現 2.4.1 複素数の表現 2.4.2 タグつきデータ 2.4.3 データ主導プログラミングと加法性 2.5 ジェネリック演算によるシステム 2.5.1 ジェネリック算術演算 2.5.2 異なる型のデータを組み合わせる 2.5.3 例: 記号代数 3 モジュール性、オブジェクト、状態 3.1 代入と局所状態 3.1.1 局所状態変数 3.1.2 代入を導入する利点 3.1.3 代入を導入することのコスト 3.2 評価の環境モデル 3.2.1 評価規則 3.2.2 単純な手続きの適用 3.2.3 局所状態の保管場所としてのフレーム 3.2.4 内部定義 3.3 可変データによるモデル化 3.3.1 可変リスト構造 3.3.2 キューの表現 3.3.3 テーブルの表現 3.3.4 デジタル回路シミュレータ 3.3.5 制約伝播 3.4 並行性: 期限厳守 3.4.1 並行システムにおける時間の性質 3.4.2 並行性制御メカニズム 3.5 ストリーム 3.5.1 ストリーム＝遅延リスト 3.5.2 無限ストリーム 3.5.3 ストリームパラダイムの活用 3.5.4 ストリームと遅延評価 3.5.5 関数型プログラムのモジュール性とオブジェクトのモジュール性 4 メタ言語抽象化 4.1 メタ循環評価器 4.1.1 評価器のコア 4.1.2 式の表現 4.1.3 評価器のデータ構造 4.1.4 評価器をプログラムとして実行する 4.1.5 プログラムとしてのデータ 4.1.6 内部定義 4.1.7 構文解析を実行から分離する 4.2 Schemeの変異版 --- 遅延評価 4.2.1 正規順序と適用順序 4.2.2 遅延評価のインタプリタ 4.2.3 遅延化リストとしてのストリーム 4.3 Schemeの変異版 --- 非決定性計算 4.3.1 ambと探索 4.3.2 非決定性プログラムの例 4.3.3 \\code{amb}評価器の実装 4.4 論理プログラミング 4.4.1 推論的情報検索 4.4.2 クエリシステムの仕組み 4.4.3 論理プログラミングは数学論理学か 4.4.4 クエリシステムの実装 4.4.4.1 ドライバループと具体化 4.4.4.2 評価器 4.4.4.3 パターンマッチングによる表明の検索 4.4.4.4 規則とユニフィケーション 4.4.4.5 データベースの保守 4.4.4.6 ストリーム演算 4.4.4.7 クエリ構文手続き 4.4.4.8 フレームと束縛 5 レジスタマシンによる計算 5.1 レジスタマシンの設計 5.1.1 レジスタマシンの記述言語 5.1.2 マシン設計における抽象化 5.1.3 サブルーチン 5.1.4 再帰の実装にスタックを使う 5.1.5 命令まとめ 5.2 レジスタマシンシミュレータ 5.2.1 マシンモデル 5.2.2 アセンブラ 5.2.3 命令の実行手続きの生成 5.2.4 マシンパフォーマンスの監視 5.3 記憶領域の割り当てとガベージコレクション 5.3.1 ベクタとしてのメモリ 5.3.2 無限メモリ幻想の維持 5.4 明示制御評価器 5.4.1 明示制御評価器のコア 5.4.2 列の評価と末尾再帰 5.4.3 条件文、代入、定義 5.4.4 評価器の実行 5.5 コンパイル 5.5.1 コンパイラの構造 5.5.2 式のコンパイル 5.5.3 組み合わせのコンパイル 5.5.4 命令列のコンパイル 5.5.5 コンパイル済みコードの例 5.5.6 レキシカルアドレッシング 5.5.7 コンパイル済みコードと評価器の接続 参考文献 練習問題リスト 図一覧 索引 奥付 "},"Unofficial_Texinfo_Format.html":{"url":"Unofficial_Texinfo_Format.html","title":"非公式Texinfoフォーマット","keywords":"","body":"非公式Texinfoフォーマット これはSICPの非公式Texinfo版訳注1の第二版です。 あなたはきっと、これをEmacsのInfoモードのようなInfoハイパーテキストブラウザで読んでいるのでしょう。もしかすると、LaTeX\\LaTeXLATE​Xで組版されたものを画面上で、または印刷して読んでいるのかもしれませんね。もっとも、それは間抜けなことだと思いますが。それに、印刷するにはだいぶお金がかかりますよね。 HTML-GIF版は公式に無料で公開されているのですが、それを初めてUnofficial Texinfo Format(非公式Texinfo版、UTF)の初版としてLytha Aythが個人的に変換したのは、2001年4月の長いEmacs Lovefest Weekendの間のことでした。 UTFはHTML版よりも検索が簡単です。また、あまりよくないコンピュータ(例えば寄付された386マシンのようなもの)を使っている人にとってもアクセスしやすいでしょう。 386マシンは、理論的には、Linux、Emacs、Schemeインタプリタを同時に実行できます。 しかし、多くの386マシンでは、Netscapeとそれに必要なX Window Systemの両方を動かそうとすると、まだ始めたてでお金もない若いハッカーにスラッシング(thrashing)という概念を早い段階から教えるはめになるのがオチです。それに、UTF版なら圧縮なしで1.44MBのフロッピーディスクに収まりますので、インターネットやLANへの接続環境のないPCに インストールするのにも便利です。 Texinfoへの変換は、可能な範囲で直接的な翻字をしました。TeX\\TeXTE​XからHTMLへの変換のように、これによってある程度内容が損なわれてしまいました。非公式TexInfo形式では、図はいにしえの技術であるアスキーアートによって不格好に復活させられることになりました。 また、多量の上付き文字(‘ˆ’)と下付き文字(‘_’)を変換するうちに、曖昧さによる変換ミスが含まれてしまった可能性も大いにあります。どれが変換ミスかを当てるのは、読者への課題とします。 しかし、少なくとも私たちは、“より大きい”という記号を&gt;\\texttt{\\&gt;}&gt;と符号化して私たちの勇敢な宇宙飛行士たちを危険にさらすようなことはしていません。 もしあなたがsicp.texi\\texttt{sicp.texi}sicp.texiを変更して間違いを直したりアスキーアートを改善したりした場合、@set utfversion 2.andresraba5.5\\texttt{@set utfversion 2.andresraba5.5}@set utfversion 2.andresraba5.5の行を更新し、あなたの差分を反映してください。 例えば、もしあなたがLythaのバージョン1\\texttt{1}1から始めていて、あなたの名前がBobなら、改訂版には1.bob1\\texttt{1.bob1}1.bob1, 1.bob2\\texttt{1.bob2}1.bob2, …\\dots… , 1.bobn\\texttt{1.bob\\textit{n}}1.bobnのように名前をつけるのがいいでしょう。 また、utfversiondate\\texttt{utfversiondate}utfversiondateも更新してください。もしあなたが自分の改訂版をWeb上で配布したいのなら、文字列“sicp.texi”をファイルやWebページのどこかに埋め込んでおけば、Web検索エンジンから見つけやすくなるでしょう。 非公式Texinfo形式は、寛大にもフリーに配布されているHTML版の魂を引き継いでいると信じられています。しかし、いつどこかの法律家の大艦隊が、何でもないような小さなことをめぐって大騒ぎをしないとも限りません。ですから、あなたのフルネームを使ったり、あなたのアカウント名やマシン名を含むかもしれないInfo, DVI, PostScript, PDF版を配布したりするのは慎重に考えてからにしてください。 Peath, Lytha Ayth 付録:AbelsonとSussmanによるSICPのビデオレクチャーもご覧ください。 MIT CSAIL, MIT OCW. 付録2:上記は2001年の元のUTFの紹介です。 10年後のいま、UTFは一変しました。数学上の記号と式は適切に組版され、図はベクターグラフィックにより描かれています。元のテキスト形式とアスキーアートの図は今でもTexinfoのソースに残っていますが、表示されるのはInfo形式にコンパイルした場合だけです。 電子書籍リーダーとタブレットの夜明け時代になって、画面上でPDFを読むことは、もはや馬鹿馬鹿しいことではないとはっきり言えるようになりました。 楽しんでください！ 訳注1. 英語版にはTexinfo版がありますが、日本語版にはありません。LaTeX\\LaTeXLATE​XソースとPDFのみです。 ↩ "}}