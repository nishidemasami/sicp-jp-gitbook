# Summary

* [Contents](SUMMARY.md)
* [Unofficial Texinfo Format](Unofficial_Texinfo_Format.md)
* [Dedication](Dedication.md)
* [Foreword](Foreword.md)
* [Preface to the Second Edition](Preface_to_the_Second_Edition.md)
* [Preface to the First Edition](Preface_to_the_First_Edition.md)
* [Acknowledgments](Acknowledgments.md)
* [1 Building Abstractions with Procedures](1_Building_Abstractions_with_Procedures.md)
  * [1.1 The Elements of Programming](1.1_The_Elements_of_Programming.md)
    * [1.1.1 Expressions](1.1.1_Expressions.md)
    * [1.1.2 Naming and the Environment](1.1.2_Naming_and_the_Environment.md)
    * [1.1.3 Evaluating Combinations](1.1.3_Evaluating_Combinations.md)
    * [1.1.4 Compound Procedures](1.1.4_Compound_Procedures.md)
    * [1.1.5 The Substitution Model for Procedure Application](1.1.5_1.1.1_The_Substitution_Model_for_Procedure_Application.md)
    * [1.1.6 Conditional Expressions and Predicates](1.1.6_Conditional_Expressions_and_Predicates.md)
    * [1.1.7 Example: Square Roots by Newton’s Method](1.1.7_Example_Square_Roots_by_Newtons_Method.md)
    * [1.1.8 Procedures as Black-Box Abstractions](1.1.8_Procedures_as_Black_Box_Abstractions.md)
  * [1.2 Procedures and the Processes They Generate](1.2_Procedures_and_the_Processes_They_Generate.md)
    * [1.2.1 Linear Recursion and Iteration](1.2.1_Linear_Recursion_and_Iteration.md)
    * [1.2.2 Tree Recursion](1.2.2_Tree_Recursion.md)
    * [1.2.3 Orders of Growth](1.2.3_Orders_of_Growth.md)
    * [1.2.4 Exponentiation](1.2.4_Exponentiation.md)
    * [1.2.5 Greatest Common Divisors](1.2.5_Greatest_Common_Divisors.md)
    * [1.2.6 Example: Testing for Primality](1.2.6_Example_Testing_for_Primality.md)
  * [1.3 Formulating Abstractions with Higher-Order Procedures](1.3_Formulating_Abstractions_with_Higher_Order_Procedures.md)
    * [1.3.1 Procedures as Arguments](1.3.1_Procedures_as_Arguments.md)
    * [1.3.2 Constructing Procedures Using lambda](1.3.2_Constructing_Procedures_Using_lambda.md)
    * [1.3.3 Procedures as General Methods](1.3.3_Procedures_as_General_Methods.md)
    * [1.3.4 Procedures as Returned Values](1.3.4_Procedures_as_Returned_Values.md)
* [2 Building Abstractions with Data](2_Building_Abstractions_with_Data.md)
  * [2.1 Introduction to Data Abstraction](2.1_Introduction_to_Data_Abstraction.md)
    * [2.1.1 Example: Arithmetic Operations for Rational Numbers](2.1.1_Example_Arithmetic_Operations_for_Rational_Numbers.md)
    * [2.1.2 Abstraction Barriers](2.1.2_Abstraction_Barriers.md)
    * [2.1.3 What Is Meant by Data?](2.1.3_What_Is_Meant_by_Data.md)
    * [2.1.4 Extended Exercise: Interval Arithmetic](2.1.4_Extended_Exercise_Interval_Arithmetic.md)
  * [2.2 Hierarchical Data and the Closure Property](2.2_Hierarchical_Data_and_the_Closure_Property.md)
    * [2.2.1 Representing Sequences](2.2.1_Representing_Sequences.md)
    * [2.2.2 Hierarchical Structures](2.2.2_Hierarchical_Structures.md)
    * [2.2.3 Sequences as Conventional Interfaces](2.2.3_Sequences_as_Conventional_Interfaces.md)
    * [2.2.4 Example: A Picture Language](2.2.4_Example_A_Picture_Language.md)
  * [2.3 Symbolic Data](2.3_Symbolic_Data.md)
    * [2.3.1 Quotation](2.3.1_Quotation.md)
    * [2.3.2 Example: Symbolic Differentiation](2.3.2_Example_Symbolic_Differentiation.md)
    * [2.3.3 Example: Representing Sets](2.3.3_Example_Representing_Sets.md)
    * [2.3.4 Example: Huffman Encoding Trees](2.3.4_Example_Huffman_Encoding_Trees.md)
  * [2.4 Multiple Representations for Abstract Data](2.4_Multiple_Representations_for_Abstract_Data.md)
    * [2.4.1 Representations for Complex Numbers](2.4.1_Representations_for_Complex_Numbers.md)
    * [2.4.2 Tagged data](2.4.2_Tagged_data.md)
    * [2.4.3 Data-Directed Programming and Additivity](2.4.3_Data_Directed_Programming_and_Additivity.md)
  * [2.5 Systems with Generic Operations](2.5_Systems_with_Generic_Operations.md)
    * [2.5.1 Generic Arithmetic Operations](2.5.1_Generic_Arithmetic_Operations.md)
    * [2.5.2 Combining Data of Different Types](2.5.2_Combining_Data_of_Different_Types.md)
    * [2.5.3 Example: Symbolic Algebra](2.5.3_Example_Symbolic_Algebra.md)
* [3 Modularity, Objects, and State](3_Modularity_Objects_and_State.md)
  * [3.1 Assignment and Local State](3.1_Assignment_and_Local_State.md)
    * [3.1.1 Local State Variables](3.1.1_Local_State_Variables.md)
    * [3.1.2 The Benefits of Introducing Assignment](3.1.2_The_Benefits_of_Introducing_Assignment.md)
    * [3.1.3 The Costs of Introducing Assignment](3.1.3_The_Costs_of_Introducing_Assignment.md)
  * [3.2 The Environment Model of Evaluation](3.2_The_Environment_Model_of_Evaluation.md)
    * [3.2.1 The Rules for Evaluation](3.2.1_The_Rules_for_Evaluation.md)
    * [3.2.2 Applying Simple Procedures](3.2.2_Applying_Simple_Procedures.md)
    * [3.2.3 Frames as the Repository of Local State](3.2.3_Frames_as_the_Repository_of_Local_State.md)
    * [3.2.4 Internal Definitions](3.2.4_Internal_Definitions.md)
  * [3.3 Modeling with Mutable Data](3.3_Modeling_with_Mutable_Data.md)
    * [3.3.1 Mutable List Structure](3.3.1_Mutable_List_Structure.md)
    * [3.3.2 Representing Queues](3.3.2_Representing_Queues.md)
    * [3.3.3 Representing Tables](3.3.3_Representing_Tables.md)
    * [3.3.4 A Simulator for Digital Circuits](3.3.4_A_Simulator_for_Digital_Circuits.md)
    * [3.3.5 Propagation of Constraints](3.3.5_Propagation_of_Constraints.md)
  * [3.4 Concurrency: Time Is of the Essence](3.4_Concurrency_Time_Is_of_the_Essence.md)
    * [3.4.1 The Nature of Time in Concurrent Systems](3.4.1_The_Nature_of_Time_in_Concurrent_Systems.md)
    * [3.4.2 Mechanisms for Controlling Concurrency](3.4.2_Mechanisms_for_Controlling_Concurrency.md)
  * [3.5 Streams](3.5_Streams.md)
    * [3.5.1 Streams Are Delayed Lists](3.5.1_Streams_Are_Delayed_Lists.md)
    * [3.5.2 Infinite Streams](3.5.2_Infinite_Streams.md)
    * [3.5.3 Exploiting the Stream Paradigm](3.5.3_Exploiting_the_Stream_Paradigm.md)
    * [3.5.4 Streams and Delayed Evaluation](3.5.4_Streams_and_Delayed_Evaluation.md)
    * [3.5.5 Modularity of Functional Programs and Modularity of Objects](3.5.5_Modularity_of_Functional_Programs_and_Modularity_of_Objects.md)
* [4 Metalinguistic Abstraction](4_Metalinguistic_Abstraction.md)
  * [4.1 The Metacircular Evaluator](4.1_The_Metacircular_Evaluator.md)
    * [4.1.1 The Core of the Evaluator](4.1.1_The_Core_of_the_Evaluator.md)
    * [4.1.2 Representing Expressions](4.1.2_Representing_Expressions.md)
    * [4.1.3 Evaluator Data Structures](4.1.3_Evaluator_Data_Structures.md)
    * [4.1.4 Running the Evaluator as a Program](4.1.4_Running_the_Evaluator_as_a_Program.md)
    * [4.1.5 Data as Programs](4.1.5_Data_as_Programs.md)
    * [4.1.6 Internal Definitions](4.1.6_Internal_Definitions.md)
    * [4.1.7 Separating Syntactic Analysis from Execution](4.1.7_Separating_Syntactic_Analysis_from_Execution.md)
  * [4.2 Variations on a Scheme — Lazy Evaluation](4.2_Variations_on_a_Scheme_Lazy_Evaluation.md)
    * [4.2.1 Normal Order and Applicative Order](4.2.1_Normal_Order_and_Applicative_Order.md)
    * [4.2.2 An Interpreter with Lazy Evaluation](4.2.2_An_Interpreter_with_Lazy_Evaluation.md)
    * [4.2.3 Streams as Lazy Lists](4.2.3_Streams_as_Lazy_Lists.md)
  * [4.3 Variations on a Scheme — Nondeterministic Computing](4.3_Variations_on_a_Scheme_Nondeterministic_Computing.md)
    * [4.3.1 Amb and Search](4.3.1_Amb_and_Search.md)
    * [4.3.2 Examples of Nondeterministic Programs](4.3.2_Examples_of_Nondeterministic_Programs.md)
    * [4.3.3 Implementing the amb Evaluator](4.3.3_Implementing_the_amb_Evaluator.md)
  * [4.4 Logic Programming](4.4_Logic_Programming.md)
    * [4.4.1 Deductive Information Retrieval](4.4.1_Deductive_Information_Retrieval.md)
    * [4.4.2 How the Query System Works](4.4.2_How_the_Query_System_Works.md)
    * [4.4.3 Is Logic Programming Mathematical Logic?](4.4.3_Is_Logic_Programming_Mathematical_Logic.md)
    * [4.4.4 Implementing the Query System](4.4.4_Implementing_the_Query_System.md)
      * [4.4.4.1 The Driver Loop and Instantiation](4.4.4.1_The_Driver_Loop_and_Instantiation.md)
      * [4.4.4.2 The Evaluator](4.4.4.2_The_Evaluator.md)
      * [4.4.4.3 Finding Assertions by Pattern Matching](4.4.4.3_Finding_Assertions_by_Pattern_Matching.md)
      * [4.4.4.4 Rules and Unification](4.4.4.4_Rules_and_Unification.md)
      * [4.4.4.5 Maintaining the Data Base](4.4.4.5_Maintaining_the_Data_Base.md)
      * [4.4.4.6 Stream Operations](4.4.4.6_Stream_Operations.md)
      * [4.4.4.7 Query Syntax Procedures](4.4.4.7_Query_Syntax_Procedures.md)
      * [4.4.4.8 Frames and Bindings](4.4.4.8_Frames_and_Bindings.md)
* [5 Computing with Register Machines](5_Computing_with_Register_Machines.md)
  * [5.1 Designing Register Machines](5.1_Designing_Register_Machines.md)
    * [5.1.1 A Language for Describing Register Machines](5.1.1_A_Language_for_Describing_Register_Machines.md)
    * [5.1.2 Abstraction in Machine Design](5.1.2_Abstraction_in_Machine_Design.md)
    * [5.1.3 Subroutines](5.1.3_Subroutines.md)
    * [5.1.4 Using a Stack to Implement Recursion](5.1.4_Using_a_Stack_to_Implement_Recursion.md)
    * [5.1.5 Instruction Summary](5.1.5_Instruction_Summary.md)
  * [5.2 A Register-Machine Simulator](5.2_A_Register_Machine_Simulator.md)
    * [5.2.1 The Machine Model](5.2.1_The_Machine_Model.md)
    * [5.2.2 The Assembler](5.2.2_The_Assembler.md)
    * [5.2.3 Generating Execution Procedures for Instructions](5.2.3_Generating_Execution_Procedures_for_Instructions.md)
    * [5.2.4 Monitoring Machine Performance](5.2.4_Monitoring_Machine_Performance.md)
  * [5.3 Storage Allocation and Garbage Collection](5.3_Storage_Allocation_and_Garbage_Collection.md)
    * [5.3.1 Memory as Vectors](5.3.1_Memory_as_Vectors.md)
    * [5.3.2 Maintaining the Illusion of Infinite Memory](5.3.2_Maintaining_the_Illusion_of_Infinite_Memory.md)
  * [5.4 The Explicit-Control Evaluator](5.4_The_Explicit_Control_Evaluator.md)
    * [5.4.1 The Core of the Explicit-Control Evaluator](5.4.1_The_Core_of_the_Explicit_Control_Evaluator.md)
    * [5.4.2 Sequence Evaluation and Tail Recursion](5.4.2_Sequence_Evaluation_and_Tail_Recursion.md)
    * [5.4.3 Conditionals, Assignments, and Definitions](5.4.3_Conditionals_Assignments_and_Definitions.md)
    * [5.4.4 Running the Evaluator](5.4.4_Running_the_Evaluator.md)
  * [5.5 Compilation](5.5_Compilation.md)
    * [5.5.1 Structure of the Compiler](5.5.1_Structure_of_the_Compiler.md)
    * [5.5.2 Compiling Expressions](5.5.2_Compiling_Expressions.md)
    * [5.5.3 Compiling Combinations](5.5.3_Compiling_Combinations.md)
    * [5.5.4 Combining Instruction Sequences](5.5.4_Combining_Instruction_Sequences.md)
    * [5.5.5 An Example of Compiled Code](5.5.5_An_Example_of_Compiled_Code.md)
    * [5.5.6 Lexical Addressing](5.5.6_Lexical_Addressing.md)
    * [5.5.7 Interfacing Compiled Code to the Evaluator](5.5.7_Interfacing_Compiled_Code_to_the_Evaluator.md)
* [References](References.md)
* [List of Exercises](List_of_Exercises.md)
* [List of Figures](List_of_Figures.md)
* [Index](Index.md)
* [Colophon](Colophon.md)