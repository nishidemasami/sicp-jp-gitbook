{"./":{"url":"./","title":"Introduction","keywords":"","body":" image/svg+xml --> Structure and Interpretationof Computer Programs Harold Abelson and Gerald Jay Sussmanwith Julie Sussman, foreword by Alan J. Perlis Unoﬃcial ebook version 2.andresraba6.6 second edition "},"SUMMARY.html":{"url":"SUMMARY.html","title":"Contents","keywords":"","body":"Summary Contents Unofficial Texinfo Format Dedication Foreword Preface to the Second Edition Preface to the First Edition Acknowledgments 1 Building Abstractions with Procedures 1.1 The Elements of Programming 1.1.1 Expressions 1.1.2 Naming and the Environment 1.1.3 Evaluating Combinations 1.1.4 Compound Procedures 1.1.5 The Substitution Model for Procedure Application 1.1.6 Conditional Expressions and Predicates 1.1.7 Example: Square Roots by Newton’s Method 1.1.8 Procedures as Black-Box Abstractions 1.2 Procedures and the Processes They Generate 1.2.1 Linear Recursion and Iteration 1.2.2 Tree Recursion 1.2.3 Orders of Growth 1.2.4 Exponentiation 1.2.5 Greatest Common Divisors 1.2.6 Example: Testing for Primality 1.3 Formulating Abstractions with Higher-Order Procedures 1.3.1 Procedures as Arguments 1.3.2 Constructing Procedures Using lambda 1.3.3 Procedures as General Methods 1.3.4 Procedures as Returned Values 2 Building Abstractions with Data 2.1 Introduction to Data Abstraction 2.1.1 Example: Arithmetic Operations for Rational Numbers 2.1.2 Abstraction Barriers 2.1.3 What Is Meant by Data? 2.1.4 Extended Exercise: Interval Arithmetic 2.2 Hierarchical Data and the Closure Property 2.2.1 Representing Sequences 2.2.2 Hierarchical Structures 2.2.3 Sequences as Conventional Interfaces 2.2.4 Example: A Picture Language 2.3 Symbolic Data 2.3.1 Quotation 2.3.2 Example: Symbolic Differentiation 2.3.3 Example: Representing Sets 2.3.4 Example: Huffman Encoding Trees 2.4 Multiple Representations for Abstract Data 2.4.1 Representations for Complex Numbers 2.4.2 Tagged data 2.4.3 Data-Directed Programming and Additivity 2.5 Systems with Generic Operations 2.5.1 Generic Arithmetic Operations 2.5.2 Combining Data of Different Types 2.5.3 Example: Symbolic Algebra 3 Modularity, Objects, and State 3.1 Assignment and Local State 3.1.1 Local State Variables 3.1.2 The Benefits of Introducing Assignment 3.1.3 The Costs of Introducing Assignment 3.2 The Environment Model of Evaluation 3.2.1 The Rules for Evaluation 3.2.2 Applying Simple Procedures 3.2.3 Frames as the Repository of Local State 3.2.4 Internal Definitions 3.3 Modeling with Mutable Data 3.3.1 Mutable List Structure 3.3.2 Representing Queues 3.3.3 Representing Tables 3.3.4 A Simulator for Digital Circuits 3.3.5 Propagation of Constraints 3.4 Concurrency: Time Is of the Essence 3.4.1 The Nature of Time in Concurrent Systems 3.4.2 Mechanisms for Controlling Concurrency 3.5 Streams 3.5.1 Streams Are Delayed Lists 3.5.2 Infinite Streams 3.5.3 Exploiting the Stream Paradigm 3.5.4 Streams and Delayed Evaluation 3.5.5 Modularity of Functional Programs and Modularity of Objects 4 Metalinguistic Abstraction 4.1 The Metacircular Evaluator 4.1.1 The Core of the Evaluator 4.1.2 Representing Expressions 4.1.3 Evaluator Data Structures 4.1.4 Running the Evaluator as a Program 4.1.5 Data as Programs 4.1.6 Internal Definitions 4.1.7 Separating Syntactic Analysis from Execution 4.2 Variations on a Scheme — Lazy Evaluation 4.2.1 Normal Order and Applicative Order 4.2.2 An Interpreter with Lazy Evaluation 4.2.3 Streams as Lazy Lists 4.3 Variations on a Scheme — Nondeterministic Computing 4.3.1 Amb and Search 4.3.2 Examples of Nondeterministic Programs 4.3.3 Implementing the amb Evaluator 4.4 Logic Programming 4.4.1 Deductive Information Retrieval 4.4.2 How the Query System Works 4.4.3 Is Logic Programming Mathematical Logic? 4.4.4 Implementing the Query System 4.4.4.1 The Driver Loop and Instantiation 4.4.4.2 The Evaluator 4.4.4.3 Finding Assertions by Pattern Matching 4.4.4.4 Rules and Unification 4.4.4.5 Maintaining the Data Base 4.4.4.6 Stream Operations 4.4.4.7 Query Syntax Procedures 4.4.4.8 Frames and Bindings 5 Computing with Register Machines 5.1 Designing Register Machines 5.1.1 A Language for Describing Register Machines 5.1.2 Abstraction in Machine Design 5.1.3 Subroutines 5.1.4 Using a Stack to Implement Recursion 5.1.5 Instruction Summary 5.2 A Register-Machine Simulator 5.2.1 The Machine Model 5.2.2 The Assembler 5.2.3 Generating Execution Procedures for Instructions 5.2.4 Monitoring Machine Performance 5.3 Storage Allocation and Garbage Collection 5.3.1 Memory as Vectors 5.3.2 Maintaining the Illusion of Infinite Memory 5.4 The Explicit-Control Evaluator 5.4.1 The Core of the Explicit-Control Evaluator 5.4.2 Sequence Evaluation and Tail Recursion 5.4.3 Conditionals, Assignments, and Definitions 5.4.4 Running the Evaluator 5.5 Compilation 5.5.1 Structure of the Compiler 5.5.2 Compiling Expressions 5.5.3 Compiling Combinations 5.5.4 Combining Instruction Sequences 5.5.5 An Example of Compiled Code 5.5.6 Lexical Addressing 5.5.7 Interfacing Compiled Code to the Evaluator References List of Exercises List of Figures Index Colophon "},"Dedication.html":{"url":"Dedication.html","title":"Dedication","keywords":"","body":"Dedication This book is dedicated, in respect and admiration, to the spirit that lives in the computer. “I think that it's extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shafted every now and then, and after a while we began to take their complaints seriously. We began to feel as if we really were responsible for the successful, error-free perfect use of these machines. I don't think we are. I think we're responsible for stretching them, setting them off in new directions, and keeping fun in the house. I hope the field of computer science never loses its sense of fun. Above all, I hope we don't become missionaries. Don't feel as if you're Bible salesmen. The world has too many of those already. What you know about computing other people will learn. Don't feel as if the key to successful computing is only in your hands. What's in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more.” ---Alan J. Perlis (April 1, 1922 -- February 7, 1990) "},"Preface_to_the_Second_Edition.html":{"url":"Preface_to_the_Second_Edition.html","title":"Preface to the Second Edition","keywords":"","body":"Preface to the Second Edition Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as a soap bubble? ---Alan J. Perlis The material in this book has been the basis of MIT's entry-level computer science subject since 1980. We had been teaching this material for four years when the first edition was published, and twelve more years have elapsed until the appearance of this second edition. We are pleased that our work has been widely adopted and incorporated into other texts. We have seen our students take the ideas and programs in this book and build them in as the core of new computer systems and languages. In literal realization of an ancient Talmudic pun, our students have become our builders. We are lucky to have such capable students and such accomplished builders. In preparing this edition, we have incorporated hundreds of clarifications suggested by our own teaching experience and the comments of colleagues at MIT and elsewhere. We have redesigned most of the major programming systems in the book, including the generic-arithmetic system, the interpreters, the register-machine simulator, and the compiler; and we have rewritten all the program examples to ensure that any Scheme implementation conforming to the IEEE Scheme standard (IEEE 1990) will be able to run the code. This edition emphasizes several new themes. The most important of these is the central role played by different approaches to dealing with time in computational models: objects with state, concurrent programming, functional programming, lazy evaluation, and nondeterministic programming. We have included new sections on concurrency and nondeterminism, and we have tried to integrate this theme throughout the book. The first edition of the book closely followed the syllabus of our MIT one-semester subject. With all the new material in the second edition, it will not be possible to cover everything in a single semester, so the instructor will have to pick and choose. In our own teaching, we sometimes skip the section on logic programming (Section 4.4), we have students use the register-machine simulator but we do not cover its implementation (Section 5.2), and we give only a cursory overview of the compiler (Section 5.5). Even so, this is still an intense course. Some instructors may wish to cover only the first three or four chapters, leaving the other material for subsequent courses. The World-Wide-Web site http://mitpress.mit.edu/sicp provides support for users of this book. This includes programs from the book, sample programming assignments, supplementary materials, and downloadable implementations of the Scheme dialect of Lisp. "},"Preface_to_the_First_Edition.html":{"url":"Preface_to_the_First_Edition.html","title":"Preface to the First Edition","keywords":"","body":"Preface to the First Edition A computer is like a violin. You can imagine a novice trying first a phonograph and then a violin. The latter, he says, sounds terrible. That is the argument we have heard from our humanists and most of our computer scientists. Computer programs are good, they say, for particular purposes, but they aren't flexible. Neither is a violin, or a typewriter, until you learn how to use it. ---Marvin Minsky, “Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas” “The Structure and Interpretation of Computer Programs” is the entry-level subject in computer science at the Massachusetts Institute of Technology. It is required of all students at MIT who major in electrical engineering or in computer science, as one-fourth of the “common core curriculum,” which also includes two subjects on circuits and linear systems and a subject on the design of digital systems. We have been involved in the development of this subject since 1978, and we have taught this material in its present form since the fall of 1980 to between 600 and 700 students each year. Most of these students have had little or no prior formal training in computation, although many have played with computers a bit and a few have had extensive programming or hardware-design experience. Our design of this introductory computer-science subject reflects two major concerns. First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute. Second, we believe that the essential material to be addressed by a subject at this level is not the syntax of particular programming-language constructs, nor clever algorithms for computing particular functions efficiently, nor even the mathematical analysis of algorithms and the foundations of computing, but rather the techniques used to control the intellectual complexity of large software systems. Our goal is that students who complete this subject should have a good feel for the elements of style and the aesthetics of programming. They should have command of the major techniques for controlling complexity in a large system. They should be capable of reading a 50-page-long program, if it is written in an exemplary style. They should know what not to read, and what they need not understand at any moment. They should feel secure about modifying a program, retaining the spirit and style of the original author. These skills are by no means unique to computer programming. The techniques we teach and draw upon are common to all of engineering design. We control complexity by building abstractions that hide details when appropriate. We control complexity by establishing conventional interfaces that enable us to construct systems by combining standard, well-understood pieces in a “mix and match” way. We control complexity by establishing new languages for describing a design, each of which emphasizes particular aspects of the design and deemphasizes others. Underlying our approach to this subject is our conviction that “computer science” is not a science and that its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called procedural epistemology---the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects. Mathematics provides a framework for dealing precisely with notions of “what is.” Computation provides a framework for dealing precisely with notions of “how to.” In teaching our material we use a dialect of the programming language Lisp. We never formally teach the language, because we don't have to. We just use it, and students pick it up in a few days. This is one great advantage of Lisp-like languages: They have very few ways of forming compound expressions, and almost no syntactic structure. All of the formal properties can be covered in an hour, like the rules of chess. After a short time we forget about syntactic details of the language (because there are none) and get on with the real issues---figuring out what we want to compute, how we will decompose problems into manageable parts, and how we will work on the parts. Another advantage of Lisp is that it supports (but does not enforce) more of the large-scale strategies for modular decomposition of programs than any other language we know. We can make procedural and data abstractions, we can use higher-order functions to capture common patterns of usage, we can model local state using assignment and data mutation, we can link parts of a program with streams and delayed evaluation, and we can easily implement embedded languages. All of this is embedded in an interactive environment with excellent support for incremental program design, construction, testing, and debugging. We thank all the generations of Lisp wizards, starting with John McCarthy, who have fashioned a fine tool of unprecedented power and elegance. Scheme, the dialect of Lisp that we use, is an attempt to bring together the power and elegance of Lisp and Algol. From Lisp we take the metalinguistic power that derives from the simple syntax, the uniform representation of programs as data objects, and the garbage-collected heap-allocated data. From Algol we take lexical scoping and block structure, which are gifts from the pioneers of programming-language design who were on the Algol committee. We wish to cite John Reynolds and Peter Landin for their insights into the relationship of Church's λ-calculus to the structure of programming languages. We also recognize our debt to the mathematicians who scouted out this territory decades before computers appeared on the scene. These pioneers include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry. "},"1_Building_Abstractions_with_Procedures.html":{"url":"1_Building_Abstractions_with_Procedures.html","title":"1 Building Abstractions with Procedures","keywords":"","body":"1 Building Abstractions with Procedures The acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three: 1. Combining several simple ideas into one compound one, and thus all complex ideas are made. 2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at once, without uniting them into one, by which it gets all its ideas of relations. 3. The third is separating them from all other ideas that accompany them in their real existence: this is called abstraction, and thus all its general ideas are made. ---John Locke, An Essay Concerning Human Understanding (1690) We are about to study the idea of a computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program. People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells. A computational process is indeed much like a sorcerer's idea of a spirit. It cannot be seen or touched. It is not composed of matter at all. However, it is very real. It can perform intellectual work. It can answer questions. It can affect the world by disbursing money at a bank or by controlling a robot arm in a factory. The programs we use to conjure processes are like a sorcerer's spells. They are carefully composed from symbolic expressions in arcane and esoteric programming languages that prescribe the tasks we want our processes to perform. A computational process, in a correctly working computer, executes programs precisely and accurately. Thus, like the sorcerer's apprentice, novice programmers must learn to understand and to anticipate the consequences of their conjuring. Even small errors (usually called bugs or glitches) in programs can have complex and unanticipated consequences. Fortunately, learning to program is considerably less dangerous than learning sorcery, because the spirits we deal with are conveniently contained in a secure way. Real-world programming, however, requires care, expertise, and wisdom. A small bug in a computer-aided design program, for example, can lead to the catastrophic collapse of an airplane or a dam or the self-destruction of an industrial robot. Master software engineers have the ability to organize programs so that they can be reasonably sure that the resulting processes will perform the tasks intended. They can visualize the behavior of their systems in advance. They know how to structure programs so that unanticipated problems do not lead to catastrophic consequences, and when problems do arise, they can debug their programs. Well-designed computational systems, like well-designed automobiles or nuclear reactors, are designed in a modular manner, so that the parts can be constructed, replaced, and debugged separately. Programming in Lisp We need an appropriate language for describing processes, and we will use for this purpose the programming language Lisp. Just as our everyday thoughts are usually expressed in our natural language (such as English, French, or Japanese), and descriptions of quantitative phenomena are expressed with mathematical notations, our procedural thoughts will be expressed in Lisp. Lisp was invented in the late 1950s as a formalism for reasoning about the use of certain kinds of logical expressions, called recursion equations, as a model for computation. The language was conceived by John McCarthy and is based on his paper “Recursive Functions of Symbolic Expressions and Their Computation by Machine” (McCarthy 1960). Despite its inception as a mathematical formalism, Lisp is a practical programming language. A Lisp interpreter is a machine that carries out processes described in the Lisp language. The first Lisp interpreter was implemented by McCarthy with the help of colleagues and students in the Artificial Intelligence Group of the MIT Research Laboratory of Electronics and in the MIT Computation Center.1 Lisp, whose name is an acronym for LISt Processing, was designed to provide symbol-manipulating capabilities for attacking programming problems such as the symbolic differentiation and integration of algebraic expressions. It included for this purpose new data objects known as atoms and lists, which most strikingly set it apart from all other languages of the period. Lisp was not the product of a concerted design effort. Instead, it evolved informally in an experimental manner in response to users' needs and to pragmatic implementation considerations. Lisp's informal evolution has continued through the years, and the community of Lisp users has traditionally resisted attempts to promulgate any “official” definition of the language. This evolution, together with the flexibility and elegance of the initial conception, has enabled Lisp, which is the second oldest language in widespread use today (only Fortran is older), to continually adapt to encompass the most modern ideas about program design. Thus, Lisp is by now a family of dialects, which, while sharing most of the original features, may differ from one another in significant ways. The dialect of Lisp used in this book is called Scheme.2 Because of its experimental character and its emphasis on symbol manipulation, Lisp was at first very inefficient for numerical computations, at least in comparison with Fortran. Over the years, however, Lisp compilers have been developed that translate programs into machine code that can perform numerical computations reasonably efficiently. And for special applications, Lisp has been used with great effectiveness.3 Although Lisp has not yet overcome its old reputation as hopelessly inefficient, Lisp is now used in many applications where efficiency is not the central concern. For example, Lisp has become a language of choice for operating-system shell languages and for extension languages for editors and computer-aided design systems. If Lisp is not a mainstream language, why are we using it as the framework for our discussion of programming? Because the language possesses unique features that make it an excellent medium for studying important programming constructs and data structures and for relating them to the linguistic features that support them. The most significant of these features is the fact that Lisp descriptions of processes, called procedures, can themselves be represented and manipulated as Lisp data. The importance of this is that there are powerful program-design techniques that rely on the ability to blur the traditional distinction between “passive” data and “active” processes. As we shall discover, Lisp's flexibility in handling procedures as data makes it one of the most convenient languages in existence for exploring these techniques. The ability to represent procedures as data also makes Lisp an excellent language for writing programs that must manipulate other programs as data, such as the interpreters and compilers that support computer languages. Above and beyond these considerations, programming in Lisp is great fun. 1. TheLisp 1 Programmer's Manual appeared in 1960, and the Lisp 1.5Programmer's Manual (McCarthy et al. 1965) was published in 1962. The early historyof Lisp is described in McCarthy 1978. ↩ 2. The two dialects in which most major Lisp programs of the1970s were written are MacLisp (Moon 1978; Pitman 1983), developed at theMIT Project MAC, and Interlisp (Teitelman 1974), developedat Bolt Beranek and Newman Inc. and the Xerox Palo Alto Research Center.Portable Standard Lisp (Hearn 1969; Griss 1981) was a Lisp dialect designed tobe easily portable between different machines. MacLisp spawned a number ofsubdialects, such as Franz Lisp, which was developed at the University ofCalifornia at Berkeley, and Zetalisp (Moon and Weinreb 1981), which was based on aspecial-purpose processor designed at the MIT Artificial IntelligenceLaboratory to run Lisp very efficiently. The Lisp dialect used in this book,called Scheme (Steele and Sussman 1975), was invented in 1975 by Guy Lewis Steele Jr. andGerald Jay Sussman of the MIT Artificial Intelligence Laboratory andlater reimplemented for instructional use at MIT. Scheme became anIEEE standard in 1990 (IEEE-1990). The Common Lisp dialect(Steele 1982, Steele 1990) was developed by the Lisp community to combinefeatures from the earlier Lisp dialects to make an industrial standard forLisp. Common Lisp became an ANSI standard in 1994 (ANSI 1994). ↩ 3. One such special application was abreakthrough computation of scientific importance---an integration of themotion of the Solar System that extended previous results by nearly two ordersof magnitude, and demonstrated that the dynamics of the Solar System ischaotic. This computation was made possible by new integration algorithms, aspecial-purpose compiler, and a special-purpose computer all implemented withthe aid of software tools written in Lisp (Abelson et al. 1992; Sussman and Wisdom 1992). ↩ "},"1.1_The_Elements_of_Programming.html":{"url":"1.1_The_Elements_of_Programming.html","title":"1.1 The Elements of Programming","keywords":"","body":"1.1 The Elements of Programming A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three mechanisms for accomplishing this: primitive expressions, which represent the simplest entities the language is concerned with, means of combination, by which compound elements are built from simpler ones, and means of abstraction, by which compound elements can be named and manipulated as units. In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distinct.) Informally, data is “stuff” that we want to manipulate, and procedures are descriptions of the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive procedures and should have methods for combining and abstracting procedures and data. In this chapter we will deal only with simple numerical data so that we can focus on the rules for building procedures.4 In later chapters we will see that these same rules allow us to build procedures to manipulate compound data as well. 4. The characterization ofnumbers as “simple data” is a barefaced bluff. In fact, the treatment ofnumbers is one of the trickiest and most confusing aspects of any programminglanguage. Some typical issues involved are these: Some computer systemsdistinguish integers, such as 2, from real numbers, such as2.71. Is the real number 2.00 different from the integer 2? Are thearithmetic operations used for integers the same as the operations used forreal numbers? Does 6 divided by 2 produce 3, or 3.0? How large a number canwe represent? How many decimal places of accuracy can we represent? Is therange of integers the same as the range of real numbers? Above and beyondthese questions, of course, lies a collection of issues concerning roundoff andtruncation errors---the entire science of numerical analysis. Since our focusin this book is on large-scale program design rather than on numericaltechniques, we are going to ignore these problems. The numerical examples inthis chapter will exhibit the usual roundoff behavior that one observes whenusing arithmetic operations that preserve a limited number of decimal places ofaccuracy in noninteger operations. ↩ "},"References.html":{"url":"References.html","title":"References","keywords":"","body":"References Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister,Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992. The SupercomputerToolkit: A general framework for special-purpose computing.International Journal of High-Speed Electronics 3(3): 337-361.–› Allen, John. 1978. Anatomy of Lisp. New York: McGraw-Hill. ANSI X3.226-1994. \\textit{American National Standard for InformationSys-tems---Programming Language---Common Lisp}. Appel, Andrew W. 1987. Garbage collection can be faster than stackallocation. Information Processing Letters 25(4): 275-279.–› Backus, John. 1978. Can programming be liberated from the von Neumann style?Communications of the ACM 21(8): 613-641.–› Baker, Henry G., Jr. 1978. List processing in real time on a serial computer.Communications of the ACM 21(4): 280-293.–› Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise.1982. The Scheme-81 architecture---System and chip. In Proceedings ofthe MIT Conference on Advanced Research in VLSI, edited byPaul Penfield, Jr. Dedham, MA: Artech House. Borning, Alan. 1977. ThingLab---An object-oriented system for buildingsimulations using constraints. In Proceedings of the 5th InternationalJoint Conference on Artificial Intelligence.\\href{http://ijcai.org/Past\\%20Proceedings/IJCAI-77-VOL1/PDF/085.pdf}{–›} Borodin, Alan, and Ian Munro. 1975. The Computational Complexity ofAlgebraic and Numeric Problems. New York: American Elsevier. Chaitin, Gregory J. 1975. Randomness and mathematical proof.Scientific American 232(5): 47-52.–› Church, Alonzo. 1941. The Calculi of Lambda-Conversion. Princeton,N.J.: Princeton University Press. Clark, Keith L. 1978. Negation as failure. In Logic and Data Bases.New York: Plenum Press, pp. 293-322.–› Clinger, William. 1982. Nondeterministic call by need is neither lazy nor byname. In Proceedings of the ACM Symposium on Lisp andFunctional Programming, pp. 226-234. Clinger, William, and Jonathan Rees. 1991. Macros that work. InProceedings of the 1991 ACM Conference on Principles ofProgramming Languages, pp. 155-162.–› Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973. Un syst`eme decommunication homme-machine en fran\\c{c}ais. Technical report, GroupeIntelligence Artificielle, Universit\\'e d'Aix Marseille, Luminy.–› Cormen, Thomas, Charles Leiserson, and Ronald Rivest. 1990. Introductionto Algorithms. Cambridge, MA: MIT Press. Darlington, John, Peter Henderson, and David Turner. 1982. FunctionalProgramming and Its Applications. New York: Cambridge University Press. Dijkstra, Edsger W. 1968a. The structure of the “THE”multiprogramming system. _Communications of the ACM_11(5): 341-346.–› Dijkstra, Edsger W. 1968b. Cooperating sequential processes. InProgramming Languages, edited by F. Genuys. New York: Academic Press,pp. 43-112.–› Dinesman, Howard P. 1968. Superior Mathematical Puzzles. New York:Simon and Schuster. deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977.AMORD: Explicit control of reasoning. In Proceedings of theACM Symposium on Artificial Intelligence and Programming Languages,pp. 116-125.–› Doyle, Jon. 1979. A truth maintenance system. _Artificial Intelligence_12: 231-272.–› Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National FifthGeneration Project: Introduction, survey, and evaluation. In FutureGeneration Computer Systems, vol. 9, pp. 105-117.–› Feeley, Marc. 1986. Deux approches `a l'implantation du languageScheme. Masters thesis, Universit\\'e de Montr\\'eal.–› Feeley, Marc and Guy Lapalme. 1987. Using closures for code generation.Journal of Computer Languages 12(1): 47-66.–› Feller, William. 1957. An Introduction to Probability Theory and ItsApplications, volume 1. New York: John Wiley \\& Sons. Fenichel, R., and J. Yochelson. 1969. A Lisp garbage collector for virtualmemory computer systems. _Communications of the ACM_12(11): 611-612.–› Floyd, Robert. 1967. Nondeterministic algorithms. JACM,14(4): 636-644.–› Forbus, Kenneth D., and Johan deKleer. 1993. Building ProblemSolvers. Cambridge, MA: MIT Press. Friedman, Daniel P., and David S. Wise. 1976. CONS should notevaluate its arguments. In Automata, Languages, and Programming: ThirdInternational Colloquium, edited by S. Michaelson and R. Milner, pp. 257-284.–› Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.Essentials of Programming Languages. Cambridge, MA: MITPress/ McGraw-Hill. Gabriel, Richard P. 1988. The Why of Y. _Lisp Pointers_2(2): 15-25.–› Goldberg, Adele, and David Robson. 1983. Smalltalk-80: The Language andIts Implementation. Reading, MA: Addison-Wesley.–› Gordon, Michael, Robin Milner, and Christopher Wadsworth. 1979.Edinburgh LCF. Lecture Notes in Computer Science, volume 78. New York:Springer-Verlag. Gray, Jim, and Andreas Reuter. 1993. Transaction Processing: Concepts andModels. San Mateo, CA: Morgan-Kaufman. Green, Cordell. 1969. Application of theorem proving to problem solving. InProceedings of the International Joint Conference on ArtificialIntelligence, pp. 219-240.–› Green, Cordell, and Bertram Raphael. 1968. The use of theorem-provingtechniques in question-answering systems. In Proceedings of theACM National Conference, pp. 169-181.–› Griss, Martin L. 1981. Portable Standard Lisp, a brief overview. UtahSymbolic Computation Group Operating Note 58, University of Utah. Guttag, John V. 1977. Abstract data types and the development of datastructures. Communications of the ACM 20(6): 396-404.–› Hamming, Richard W. 1980. Coding and Information Theory. EnglewoodCliffs, N.J.: Prentice-Hall. Hanson, Christopher P. 1990. Efficient stack allocation for tail-recur-sivelanguages. In Proceedings of ACM Conference on Lisp andFunctional Programming, pp. 106-118.–› Hanson, Christopher P. 1991. A syntactic closures macro facility. LispPointers, 4(3).–› Hardy, Godfrey H. 1921. Srinivasa Ramanujan. Proceedings of the LondonMathematical Society XIX(2). Hardy, Godfrey H., and E. M. Wright. 1960. An Introduction to theTheory of Numbers. 4th edition. New York: Oxford University Press.–› Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. IBMSystems Journal 7(2): 74-84. Hearn, Anthony C. 1969. Standard Lisp. Technical report AIM-90,Artificial Intelligence Project, Stanford University.–› Henderson, Peter. 1980. Functional Programming: Application andImplementation. Englewood Cliffs, N.J.: Prentice-Hall. Henderson, Peter. 1982. Functional Geometry. In Conference Record of the1982 ACM Symposium on Lisp and Functional Programming, pp. 179-187.–›,2002 version –› Hewitt, Carl E. 1969. PLANNER: A language for provingtheorems in robots. In Proceedings of the International JointConference on Artificial Intelligence, pp. 295-301.–› Hewitt, Carl E. 1977. Viewing control structures as patterns of passingmessages. Journal of Artificial Intelligence 8(3): 323-364.–› Hoare, C. A. R. 1972. Proof of correctness of data representations.Acta Informatica 1(1). Hodges, Andrew. 1983. Alan Turing: The Enigma. New York: Simon andSchuster. Hofstadter, Douglas R. 1979. \\textit{G\\\"odel, Escher, Bach: An Eternal GoldenBraid}. New York: Basic Books. Hughes, R. J. M. 1990. Why functional programming matters. In ResearchTopics in Functional Programming, edited by David Turner. Reading, MA:Addison-Wesley, pp. 17-42.–› IEEE Std 1178-1990. 1990. IEEE Standard for theScheme Programming Language. Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted byM. Lind, Herbert Kanner, and Robert Floyd. 1960. THUNKS: A way ofcompiling procedure statements, with some comments on procedure declarations.Unpublished manuscript. (Also, private communication from Wallace Feurzeig.) Kaldewaij, Anne. 1990. Programming: The Derivation of Algorithms. NewYork: Prentice-Hall. Knuth, Donald E. 1973. Fundamental Algorithms. Volume 1 of TheArt of Computer Programming. 2nd edition. Reading, MA: Addison-Wesley. Knuth, Donald E. 1981. Seminumerical Algorithms. Volume 2 of TheArt of Computer Programming. 2nd edition. Reading, MA: Addison-Wesley. Kohlbecker, Eugene Edmund, Jr. 1986. Syntactic extensions in the programminglanguage Lisp. Ph.D. thesis, Indiana University.–› Konopasek, Milos, and Sundaresan Jayaraman. 1984. The TK!Solver Book: AGuide to Problem-Solving in Science, Engineering, Business, andEducation. Berkeley, CA: Osborne/McGraw-Hill. Kowalski, Robert. 1973. Predicate logic as a programming language. Technicalreport 70, Department of Computational Logic, School of ArtificialIntelligence, University of Edinburgh.\\href{http://www.doc.ic.ac.uk/~rak/papers/IFIP\\%2074.pdf}{–›} Kowalski, Robert. 1979. Logic for Problem Solving. New York:North-Holland.\\href{http://www.doc.ic.ac.uk/\\%7Erak/papers/LogicForProblemSolving.pdf}{–›} Lamport, Leslie. 1978. Time, clocks, and the ordering of events in adistributed system. Communications of the ACM 21(7): 558-565.–› Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek.1981. Report on the programming language Euclid. Technical report, ComputerSystems Research Group, University of Toronto.–› Landin, Peter. 1965. A correspondence between Algol 60 and Church's lambdanotation: Part I. Communications of the ACM 8(2): 89-101. Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector basedon the lifetimes of objects. _Communications of the ACM_26(6): 419-429.–› Liskov, Barbara H., and Stephen N. Zilles. 1975. Specification techniques fordata abstractions. _IEEE Transactions on Software Engineering_1(1): 7-19.–› McAllester, David Allen. 1978. A three-valued truth-maintenance system. Memo473, MIT Artificial Intelligence Laboratory.–› McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551,MIT Artificial Intelligence Laboratory.–› McCarthy, John. 1960. Recursive functions of symbolic expressions and theircomputation by machine. _Communications of the ACM_3(4): 184-195.–› McCarthy, John. 1963. A basis for a mathematical theory of computation. InComputer Programming and Formal Systems, edited by P. Braffort andD. Hirschberg. North-Holland.–› McCarthy, John. 1978. The history of Lisp. In Proceedings of theACM SIGPLAN Conference on the History of ProgrammingLanguages.–› McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I. Levin.1965. Lisp 1.5 Programmer's Manual. 2nd edition. Cambridge, MA:MIT Press.\\href{http://www.softwarepreservation.org/projects/LISP/book/LISP\\%201.5\\%20Programmers\\%20Manual.pdf/view}{–›} McDermott, Drew, and Gerald Jay Sussman. 1972. Conniver reference manual.Memo 259, MIT Artificial Intelligence Laboratory.–› Miller, Gary L. 1976. Riemann's Hypothesis and tests for primality.Journal of Computer and System Sciences 13(3): 300-317.–› Miller, James S., and Guillermo J. Rozas. 1994. Garbage collection is fast,but a stack is faster. Memo 1462, MIT Artificial IntelligenceLaboratory.–› Moon, David. 1978. MacLisp reference manual, Version 0. Technical report,MIT Laboratory for Computer Science.–› Moon, David, and Daniel Weinreb. 1981. Lisp machine manual. Technicalreport, MIT Artificial Intelligence Laboratory.–› Morris, J. H., Eric Schmidt, and Philip Wadler. 1980. Experience with anapplicative string processing language. In Proceedings of the 7th AnnualACM SIGACT/SIGPLAN Symposium on the Principles ofProgramming Languages. Phillips, Hubert. 1934. The Sphinx Problem Book. London: Faber andFaber. Pitman, Kent. 1983. The revised MacLisp Manual (Saturday evening edition).Technical report 295, MIT Laboratory for Computer Science.–› Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.Journal of Number Theory 12: 128-138. Raymond, Eric. 1993. The New Hacker's Dictionary. 2nd edition.Cambridge, MA: MIT Press.–› Raynal, Michel. 1986. Algorithms for Mutual Exclusion. Cambridge, MA:MIT Press. Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A dialect of Lisp or,lambda: The ultimate software tool. In Conference Record of the 1982ACM Symposium on Lisp and Functional Programming, pp. 114-122.–› Rees, Jonathan, and William Clinger (eds). 1991. The ( \\rm revised^4 ) report on thealgorithmic language Scheme. Lisp Pointers, 4(3).–› Rivest, Ronald, Adi Shamir, and Leonard Adleman. 1977. A method for obtainingdigital signatures and public-key cryptosystems. Technical memo LCS/TM82,MIT Laboratory for Computer Science.–› Robinson, J. A. 1965. A machine-oriented logic based on the resolutionprinciple. Journal of the ACM 12(1): 23. Robinson, J. A. 1983. Logic programming---Past, present, and future.New Generation Computing 1: 107-124. Spafford, Eugene H. 1989. The Internet Worm: Crisis and aftermath.Communications of the ACM 32(6): 678-688.–› Steele, Guy Lewis, Jr. 1977. Debunking the “expensive procedure call” myth.In Proceedings of the National Conference of the ACM,pp. 153-62.–› Steele, Guy Lewis, Jr. 1982. An overview of Common Lisp. InProceedings of the ACM Symposium on Lisp and FunctionalProgramming, pp. 98-107. Steele, Guy Lewis, Jr. 1990. Common Lisp: The Language. 2nd edition.Digital Press.–› Steele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975. Scheme: An interpreterfor the extended lambda calculus. Memo 349, MIT ArtificialIntelligence Laboratory.–› Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin,Richard M. Stallman, and Geoffrey S. Goodfellow. 1983. The Hacker'sDictionary. New York: Harper \\& Row.–› Stoy, Joseph E. 1977. Denotational Semantics. Cambridge, MA:MIT Press. Sussman, Gerald Jay, and Richard M. Stallman. 1975. Heuristic techniques incomputer-aided circuit analysis. IEEE Transactions on Circuitsand Systems CAS-22(11): 857-865.–› Sussman, Gerald Jay, and Guy Lewis Steele Jr. 1980. Constraints---A languagefor expressing almost-hierachical descriptions. AI Journal 14: 1-39.–› Sussman, Gerald Jay, and Jack Wisdom. 1992. Chaotic evolution of the solarsystem. Science 257: 256-262.–› Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Microplannerreference manual. Memo 203A, MIT Artificial Intelligence Laboratory.–› Sutherland, Ivan E. 1963. SKETCHPAD: A man-machine graphicalcommunication system. Technical report 296, MIT Lincoln Laboratory.–› Teitelman, Warren. 1974. Interlisp reference manual. Technical report, XeroxPalo Alto Research Center.–› Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data typespecification: Parameterization and the power of specification techniques. InConference Record of the Tenth Annual ACM Symposium on Theoryof Computing, pp. 119-132. Turner, David. 1981. The future of applicative languages. InProceedings of the 3rd European Conference on Informatics, Lecture Notesin Computer Science, volume 123. New York: Springer-Verlag, pp. 334-348. Wand, Mitchell. 1980. Continuation-based program transformation strategies.Journal of the ACM 27(1): 164-180.–› Waters, Richard C. 1979. A method for analyzing loop programs.IEEE Transactions on Software Engineering 5(3): 237-247. Winograd, Terry. 1971. Procedures as a representation for data in a computerprogram for understanding natural language. Technical report AI TR-17,MIT Artificial Intelligence Laboratory.–› Winston, Patrick. 1992. Artificial Intelligence. 3rd edition. Reading,MA: Addison-Wesley. Zabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministicLisp with dependency-directed backtracking. AAAI-87,pp. 59-64.–› Zippel, Richard. 1979. Probabilistic algorithms for sparse polynomials.Ph.D. dissertation, Department of Electrical Engineering and Computer Science,MIT. Zippel, Richard. 1993. Effective Polynomial Computation. Boston, MA:Kluwer Academic Publishers. "},"Foreword.html":{"url":"Foreword.html","title":"Foreword","keywords":"","body":"Foreword Educators, generals, dieticians, psychologists, and parents program. Armies, students, and some societies are programmed. An assault on large problems employs a succession of programs, most of which spring into existence en route. These programs are rife with issues that appear to be particular to the problem at hand. To appreciate programming as an intellectual activity in its own right you must turn to computer programming; you must read and write computer programs---many of them. It doesn't matter much what the programs are about or what applications they serve. What does matter is how well they perform and how smoothly they fit with other programs in the creation of still greater programs. The programmer must seek both perfection of part and adequacy of collection. In this book the use of “program” is focused on the creation, execution, and study of programs written in a dialect of Lisp for execution on a digital computer. Using Lisp we restrict or limit not what we may program, but only the notation for our program descriptions. Our traffic with the subject matter of this book involves us with three foci of phenomena: the human mind, collections of computer programs, and the computer. Every computer program is a model, hatched in the mind, of a real or mental process. These processes, arising from human experience and thought, are huge in number, intricate in detail, and at any time only partially understood. They are modeled to our permanent satisfaction rarely by our computer programs. Thus even though our programs are carefully handcrafted discrete collections of symbols, mosaics of interlocking functions, they continually evolve: we change them as our perception of the model deepens, enlarges, generalizes until the model ultimately attains a metastable place within still another model with which we struggle. The source of the exhilaration associated with computer programming is the continual unfolding within the mind and on the computer of mechanisms expressed as programs and the explosion of perception they generate. If art interprets our dreams, the computer executes them in the guise of programs! For all its power, the computer is a harsh taskmaster. Its programs must be correct, and what we wish to say must be said accurately in every detail. As in every other symbolic activity, we become convinced of program truth through argument. Lisp itself can be assigned a semantics (another model, by the way), and if a program's function can be specified, say, in the predicate calculus, the proof methods of logic can be used to make an acceptable correctness argument. Unfortunately, as programs get large and complicated, as they almost always do, the adequacy, consistency, and correctness of the specifications themselves become open to doubt, so that complete formal arguments of correctness seldom accompany large programs. Since large programs grow from small ones, it is crucial that we develop an arsenal of standard program structures of whose correctness we have become sure---we call them idioms---and learn to combine them into larger structures using organizational techniques of proven value. These techniques are treated at length in this book, and understanding them is essential to participation in the Promethean enterprise called programming. More than anything else, the uncovering and mastery of powerful organizational techniques accelerates our ability to create large, significant programs. Conversely, since writing large programs is very taxing, we are stimulated to invent new methods of reducing the mass of function and detail to be fitted into large programs. Unlike programs, computers must obey the laws of physics. If they wish to perform rapidly---a few nanoseconds per state change---they must transmit electrons only small distances (at most 1121{1\\over2}121​ feet). The heat generated by the huge number of devices so concentrated in space has to be removed. An exquisite engineering art has been developed balancing between multiplicity of function and density of devices. In any event, hardware always operates at a level more primitive than that at which we care to program. The processes that transform our Lisp programs to “machine” programs are themselves abstract models which we program. Their study and creation give a great deal of insight into the organizational programs associated with programming arbitrary models. Of course the computer itself can be so modeled. Think of it: the behavior of the smallest physical switching element is modeled by quantum mechanics described by differential equations whose detailed behavior is captured by numerical approximations represented in computer programs executing on computers composed of …! It is not merely a matter of tactical convenience to separately identify the three foci. Even though, as they say, it's all in the head, this logical separation induces an acceleration of symbolic traffic between these foci whose richness, vitality, and potential is exceeded in human experience only by the evolution of life itself. At best, relationships between the foci are metastable. The computers are never large enough or fast enough. Each breakthrough in hardware technology leads to more massive programming enterprises, new organizational principles, and an enrichment of abstract models. Every reader should ask himself periodically “Toward what end, toward what end?”---but do not ask it too often lest you pass up the fun of programming for the constipation of bittersweet philosophy. Among the programs we write, some (but never enough) perform a precise mathematical function such as sorting or finding the maximum of a sequence of numbers, determining primality, or finding the square root. We call such programs algorithms, and a great deal is known of their optimal behavior, particularly with respect to the two important parameters of execution time and data storage requirements. A programmer should acquire good algorithms and idioms. Even though some programs resist precise specifications, it is the responsibility of the programmer to estimate, and always to attempt to improve, their performance. Lisp is a survivor, having been in use for about a quarter of a century. Among the active programming languages only Fortran has had a longer life. Both languages have supported the programming needs of important areas of application, Fortran for scientific and engineering computation and Lisp for artificial intelligence. These two areas continue to be important, and their programmers are so devoted to these two languages that Lisp and Fortran may well continue in active use for at least another quarter-century. Lisp changes. The Scheme dialect used in this text has evolved from the original Lisp and differs from the latter in several important ways, including static scoping for variable binding and permitting functions to yield functions as values. In its semantic structure Scheme is as closely akin to Algol 60 as to early Lisps. Algol 60, never to be an active language again, lives on in the genes of Scheme and Pascal. It would be difficult to find two languages that are the communicating coin of two more different cultures than those gathered around these two languages. Pascal is for building pyramids---imposing, breathtaking, static structures built by armies pushing heavy blocks into place. Lisp is for building organisms---imposing, breathtaking, dynamic structures built by squads fitting fluctuating myriads of simpler organisms into place. The organizing principles used are the same in both cases, except for one extraordinarily important difference: The discretionary exportable functionality entrusted to the individual Lisp programmer is more than an order of magnitude greater than that to be found within Pascal enterprises. Lisp programs inflate libraries with functions whose utility transcends the application that produced them. The list, Lisp's native data structure, is largely responsible for such growth of utility. The simple structure and natural applicability of lists are reflected in functions that are amazingly nonidiosyncratic. In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation. It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures. As a result the pyramid must stand unchanged for a millennium; the organism must evolve or perish. To illustrate this difference, compare the treatment of material and exercises within this book with that in any first-course text using Pascal. Do not labor under the illusion that this is a text digestible at MIT only, peculiar to the breed found there. It is precisely what a serious book on programming Lisp must be, no matter who the student is or where it is used. Note that this is a text about programming, unlike most Lisp books, which are used as a preparation for work in artificial intelligence. After all, the critical programming concerns of software engineering and artificial intelligence tend to coalesce as the systems under investigation become larger. This explains why there is such growing interest in Lisp outside of artificial intelligence. As one would expect from its goals, artificial intelligence research generates many significant programming problems. In other programming cultures this spate of problems spawns new languages. Indeed, in any very large programming task a useful organizing principle is to control and isolate traffic within the task modules via the invention of language. These languages tend to become less primitive as one approaches the boundaries of the system where we humans interact most often. As a result, such systems contain complex language-processing functions replicated many times. Lisp has such a simple syntax and semantics that parsing can be treated as an elementary task. Thus parsing technology plays almost no role in Lisp programs, and the construction of language processors is rarely an impediment to the rate of growth and change of large Lisp systems. Finally, it is this very simplicity of syntax and semantics that is responsible for the burden and freedom borne by all Lisp programmers. No Lisp program of any size beyond a few lines can be written without being saturated with discretionary functions. Invent and fit; have fits and reinvent! We toast the Lisp programmer who pens his thoughts within nests of parentheses. Alan J. PerlisNew Haven, Connecticut "},"Acknowledgments.html":{"url":"Acknowledgments.html","title":"Acknowledgments","keywords":"","body":"Acknowledgments We would like to thank the many people who have helped us develop this book and this curriculum. Our subject is a clear intellectual descendant of “6.231,” a wonderful subject on programming linguistics and the λ-calculus taught at MIT in the late 1960s by Jack Wozencraft and Arthur Evans, Jr. We owe a great debt to Robert Fano, who reorganized MIT's introductory curriculum in electrical engineering and computer science to emphasize the principles of engineering design. He led us in starting out on this enterprise and wrote the first set of subject notes from which this book evolved. Much of the style and aesthetics of programming that we try to teach were developed in conjunction with Guy Lewis Steele Jr., who collaborated with Gerald Jay Sussman in the initial development of the Scheme language. In addition, David Turner, Peter Henderson, Dan Friedman, David Wise, and Will Clinger have taught us many of the techniques of the functional programming community that appear in this book. Joel Moses taught us about structuring large systems. His experience with the Macsyma system for symbolic computation provided the insight that one should avoid complexities of control and concentrate on organizing the data to reflect the real structure of the world being modeled. Marvin Minsky and Seymour Papert formed many of our attitudes about programming and its place in our intellectual lives. To them we owe the understanding that computation provides a means of expression for exploring ideas that would otherwise be too complex to deal with precisely. They emphasize that a student's ability to write and modify programs provides a powerful medium in which exploring becomes a natural activity. We also strongly agree with Alan Perlis that programming is lots of fun and we had better be careful to support the joy of programming. Part of this joy derives from observing great masters at work. We are fortunate to have been apprentice programmers at the feet of Bill Gosper and Richard Greenblatt. It is difficult to identify all the people who have contributed to the development of our curriculum. We thank all the lecturers, recitation instructors, and tutors who have worked with us over the past fifteen years and put in many extra hours on our subject, especially Bill Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein and Peter Szolovits. We would like to specially acknowledge the outstanding teaching contributions of Franklyn Turbak, now at Wellesley; his work in undergraduate instruction set a standard that we can all aspire to. We are grateful to Jerry Saltzer and Jim Miller for helping us grapple with the mysteries of concurrency, and to Peter Szolovits and David McAllester for their contributions to the exposition of nondeterministic evaluation in Chapter 4. Many people have put in significant effort presenting this material at other universities. Some of the people we have worked closely with are Jacob Katzenelson at the Technion, Hardy Mayer at the University of California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and Jan Komorowski at the Norwegian University of Science and Technology. We are exceptionally proud of our colleagues who have received major teaching awards for their adaptations of this subject at other universities, including Kenneth Yip at Yale, Brian Harvey at the University of California at Berkeley, and Dan Huttenlocher at Cornell. Al Moyé arranged for us to teach this material to engineers at Hewlett-Packard, and for the production of videotapes of these lectures. We would like to thank the talented instructors---in particular Jim Miller, Bill Siebert, and Mike Eisenberg---who have designed continuing education courses incorporating these tapes and taught them at universities and industry all over the world. Many educators in other countries have put in significant work translating the first edition. Michel Briand, Pierre Chamard, and André Pic produced a French edition; Susanne Daniels-Herold produced a German edition; and Fumio Motoyoshi produced a Japanese edition. We do not know who produced the Chinese edition, but we consider it an honor to have been selected as the subject of an “unauthorized” translation. It is hard to enumerate all the people who have made technical contributions to the development of the Scheme systems we use for instructional purposes. In addition to Guy Steele, principal wizards have included Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, and Stephen Adams. Others who have put in significant time are Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu. Beyond the MIT implementation, we would like to thank the many people who worked on the IEEE Scheme standard, including William Clinger and Jonathan Rees, who edited the R⁴RS, and Chris Haynes, David Bartley, Chris Hanson, and Jim Miller, who prepared the IEEE standard. Dan Friedman has been a long-time leader of the Scheme community. The community's broader work goes beyond issues of language design to encompass significant educational innovations, such as the high-school curriculum based on EdScheme by Schemer's Inc., and the wonderful books by Mike Eisenberg and by Brian Harvey and Matthew Wright. We appreciate the work of those who contributed to making this a real book, especially Terry Ehling, Larry Cohen, and Paul Bethge at the MIT Press. Ella Mazel found the wonderful cover image. For the second edition we are particularly grateful to Bernard and Ella Mazel for help with the book design, and to David Jones, TeXTeXTeX wizard extraordinaire. We also are indebted to those readers who made penetrating comments on the new draft: Jacob Katzenelson, Hardy Mayer, Jim Miller, and especially Brian Harvey, who did unto this book as Julie did unto his book Simply Scheme. Finally, we would like to acknowledge the support of the organizations that have encouraged this work over the years, including support from Hewlett-Packard, made possible by Ira Goldstein and Joel Birnbaum, and support from DARPA, made possible by Bob Kahn. "},"1.1.1_Expressions.html":{"url":"1.1.1_Expressions.html","title":"1.1.1 Expressions","keywords":"","body":"1.1.1 Expressions One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp. Imagine that you are sitting at a computer terminal. You type an expression, and the interpreter responds by displaying the result of its evaluating that expression. One kind of primitive expression you might type is a number. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number 486 the interpreter will respond by printing5 486 Expressions representing numbers may be combined with an expression representing a primitive procedure (such as +\\texttt{+}+ or *\\texttt{*}*) to form a compound expression that represents the application of the procedure to those numbers. For example: (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7 Expressions such as these, formed by delimiting a list of expressions within parentheses in order to denote procedure application, are called combinations. The leftmost element in the list is called the operator, and the other elements are called operands. The value of a combination is obtained by applying the procedure specified by the operator to the arguments that are the values of the operands. The convention of placing the operator to the left of the operands is known as prefix notation, and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate procedures that may take an arbitrary number of arguments, as in the following examples: (+ 21 35 12 7) 75 (* 25 4 12) 1200 No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses. A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested, that is, to have combinations whose elements are themselves combinations: (+ (* 3 5) (- 10 6)) 19 There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate. It is we humans who get confused by still relatively simple expressions such as (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) following a formatting convention known as pretty-printing, in which each long combination is written so that the operands are aligned vertically. The resulting indentations display clearly the structure of the expression.6 Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, evaluates the expression, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a read-eval-print loop. Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression.7 5. Throughout this book, whenwe wish to emphasize the distinction between the input typed by the user andthe response printed by the interpreter, we will show the latter in slantedcharacters. ↩ 6. Lisp systems typically provide features to aid the user informatting expressions. Two especially useful features are one thatautomatically indents to the proper pretty-print position whenever a new lineis started and one that highlights the matching left parenthesis whenever aright parenthesis is typed. ↩ 7. Lisp obeys theconvention that every expression has a value. This convention, together withthe old reputation of Lisp as an inefficient language, is the source of thequip by Alan Perlis (paraphrasing Oscar Wilde) that “Lisp programmers know thevalue of everything but the cost of nothing.” ↩ "},"Unofficial_Texinfo_Format.html":{"url":"Unofficial_Texinfo_Format.html","title":"Unofficial Texinfo Format","keywords":"","body":"Unofficial Texinfo Format This is the second edition SICP book, from Unofficial Texinfo Format. You are probably reading it in an Info hypertext browser, such as the Info mode of Emacs. You might alternatively be reading it TeXTeXTeX-formatted on your screen or printer, though that would be silly. And, if printed, expensive. The freely-distributed official HTML-and-GIF format was first converted personally to Unofficial Texinfo Format (UTF) version 1 by Lytha Ayth during a long Emacs lovefest weekend in April, 2001. The UTF is easier to search than the HTML format. It is also much more accessible to people running on modest computers, such as donated '386-based PCs. A 386 can, in theory, run Linux, Emacs, and a Scheme interpreter simultaneously, but most 386s probably can't also run both Netscape and the necessary X Window System without prematurely introducing budding young underfunded hackers to the concept of thrashing. UTF can also fit uncompressed on a 1.44MB floppy diskette, which may come in handy for installing UTF on PCs that do not have Internet or LAN access. The Texinfo conversion has been a straight transliteration, to the extent possible. Like the TeXTeXTeX-to-HTML conversion, this was not without some introduction of breakage. In the case of Unofficial Texinfo Format, figures have suffered an amateurish resurrection of the lost art of ASCII. Also, it's quite possible that some errors of ambiguity were introduced during the conversion of some of the copious superscripts (‘ˆ’) and subscripts (‘_’). Divining which has been left as an exercise to the reader. But at least we don't put our brave astronauts at risk by encoding the greater-than-or-equal symbol as &gt;\\texttt{\\&gt;}&gt;. If you modify “sicp.texi” to correct errors or improve the ASCII art, then update the @set utfversion 2.andresraba5.5\\texttt{@set utfversion 2.andresraba5.5}@set utfversion 2.andresraba5.5 line to reflect your delta. For example, if you started with Lytha's version 1\\texttt{1}1, and your name is Bob, then you could name your successive versions 1.bob1\\texttt{1.bob1}1.bob1, 1.bob2\\texttt{1.bob2}1.bob2, … 1.bobn\\texttt{1.bob\\textit{n}}1.bobn. Also update utfversiondate\\texttt{utfversiondate}utfversiondate. If you want to distribute your version on the Web, then embedding the string “sicp.texi” somewhere in the file or Web page will make it easier for people to find with Web search engines. It is believed that the Unofficial Texinfo Format is in keeping with the spirit of the graciously freely-distributed HTML version. But you never know when someone's armada of lawyers might need something to do, and get their shorts all in a knot over some benign little thing, so think twice before you use your full name or distribute Info, DVI, PostScript, or PDF formats that might embed your account or machine name. Peath, Lytha Ayth "}}