{"./":{"url":"./","title":"表紙","keywords":"","body":" 計算機プログラムの構造と解釈 Harold Abelson and Gerald Jay Sussmanwith Julie Sussman, foreword by Alan J. Perlis Unoﬃcial ebook version 2.andresraba6.6 第二版 ©1996 by The Massachusetts Institute of Technology Structure and Interpretation of Computer Programs,second edition Harold Abelson and Gerald Jay Sussmanwith Julie Sussman, foreword by Alan J. Perlis This work is licensed under a Creative CommonsAttribution-NonCommercial-ShareAlike 3.0 Unported License(CC BY-NC-SA 3.0). Based on a work at mitpress.mit.edu. The MIT PressCambridge, MassachusettsLondon, England McGraw-Hill Book CompanyNew York, St. Louis, San Francisco,Montreal, Toronto Unofficial Texinfo Format 2.andresraba5.5 (September 15, 2015),based on 2.neilvandyke4 (January 10, 2007). 日本語： by minghai based on 2.andresraba5.2 (March 31, 2014).Decent Japanese version by Hiroshi Manabe based on 2.andresraba5.2 (October 12, 2015). "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目次","keywords":"","body":"目次 表紙 目次 非公式Texinfoフォーマット 非公式日本語版 非公式日本語版 翻訳改訂版 献辞 前書き 第二版~序文 第一版~序文 謝辞 1 手続きを用いた抽象化の構築 1.1 プログラミングの要素 1.1.1 式 1.1.2 命名と環境 1.1.3 組み合わせの評価 1.1.4 複合手続き 1.1.5 手続き適用の置換モデル 1.1.6 条件式と述語 1.1.7 例: ニュートン法による平方根 1.1.8 ブラックボックス抽象化としての手続き 1.2 手続きとそれが生成するプロセス 1.2.1 線形再帰と反復 1.2.2 木の再帰 1.2.3 増加オーダー 1.2.4 指数計算 1.2.5 最大公約数 1.2.6 例: 素数判定 1.3 高階手続きによる抽象の定式化 1.3.1 引数としての手続き 1.3.2 lambda\\texttt{lambda}lambdaを使って手続きを構築する 1.3.3 汎用手法としての手続き 1.3.4 返り値としての手続き 2 データを用いた抽象化の構築 2.1 データ抽象化入門 2.1.1 例: 有理数の数値演算 2.1.2 抽象化の壁 2.1.3 データとは何か 2.1.4 発展問題: 区間演算 2.2 階層データと閉包性 2.2.1 列の表現 2.2.2 階層構造 2.2.3 標準インターフェイスとしての列 2.2.4 例: 図形言語 2.3 記号データ 2.3.1 クォート 2.3.2 例: 記号微分 2.3.3 例: 集合を表現する 2.3.4 例: ハフマン符号化木 2.4 抽象データの多重表現 2.4.1 複素数の表現 2.4.2 タグつきデータ 2.4.3 データ主導プログラミングと加法性 2.5 ジェネリック演算によるシステム 2.5.1 ジェネリック算術演算 2.5.2 異なる型のデータを組み合わせる 2.5.3 例: 記号代数 3 モジュール性、オブジェクト、状態 3.1 代入と局所状態 3.1.1 局所状態変数 3.1.2 代入を導入する利点 3.1.3 代入を導入することのコスト 3.2 評価の環境モデル 3.2.1 評価規則 3.2.2 単純な手続きの適用 3.2.3 局所状態の保管場所としてのフレーム 3.2.4 内部定義 3.3 可変データによるモデル化 3.3.1 可変リスト構造 3.3.2 キューの表現 3.3.3 テーブルの表現 3.3.4 デジタル回路シミュレータ 3.3.5 制約伝播 3.4 並行性: 期限厳守 3.4.1 並行システムにおける時間の性質 3.4.2 並行性制御メカニズム 3.5 ストリーム 3.5.1 ストリーム＝遅延リスト 3.5.2 無限ストリーム 3.5.3 ストリームパラダイムの活用 3.5.4 ストリームと遅延評価 3.5.5 関数型プログラムのモジュール性とオブジェクトのモジュール性 4 メタ言語抽象化 4.1 メタ循環評価器 4.1.1 評価器のコア 4.1.2 式の表現 4.1.3 評価器のデータ構造 4.1.4 評価器をプログラムとして実行する 4.1.5 プログラムとしてのデータ 4.1.6 内部定義 4.1.7 構文解析を実行から分離する 4.2 Schemeの変異版 --- 遅延評価 4.2.1 正規順序と適用順序 4.2.2 遅延評価のインタプリタ 4.2.3 遅延化リストとしてのストリーム 4.3 Schemeの変異版 --- 非決定性計算 4.3.1 ambと探索 4.3.2 非決定性プログラムの例 4.3.3 \\code{amb}評価器の実装 4.4 論理プログラミング 4.4.1 推論的情報検索 4.4.2 クエリシステムの仕組み 4.4.3 論理プログラミングは数学論理学か 4.4.4 クエリシステムの実装 4.4.4.1 ドライバループと具体化 4.4.4.2 評価器 4.4.4.3 パターンマッチングによる表明の検索 4.4.4.4 規則とユニフィケーション 4.4.4.5 データベースの保守 4.4.4.6 ストリーム演算 4.4.4.7 クエリ構文手続き 4.4.4.8 フレームと束縛 5 レジスタマシンによる計算 5.1 レジスタマシンの設計 5.1.1 レジスタマシンの記述言語 5.1.2 マシン設計における抽象化 5.1.3 サブルーチン 5.1.4 再帰の実装にスタックを使う 5.1.5 命令まとめ 5.2 レジスタマシンシミュレータ 5.2.1 マシンモデル 5.2.2 アセンブラ 5.2.3 命令の実行手続きの生成 5.2.4 マシンパフォーマンスの監視 5.3 記憶領域の割り当てとガベージコレクション 5.3.1 ベクタとしてのメモリ 5.3.2 無限メモリ幻想の維持 5.4 明示制御評価器 5.4.1 明示制御評価器のコア 5.4.2 列の評価と末尾再帰 5.4.3 条件文、代入、定義 5.4.4 評価器の実行 5.5 コンパイル 5.5.1 コンパイラの構造 5.5.2 式のコンパイル 5.5.3 組み合わせのコンパイル 5.5.4 命令列のコンパイル 5.5.5 コンパイル済みコードの例 5.5.6 レキシカルアドレッシング 5.5.7 コンパイル済みコードと評価器の接続 参考文献 練習問題リスト 図一覧 索引 奥付 "},"Dedication.html":{"url":"Dedication.html","title":"献辞","keywords":"","body":"献辞 この本を、尊敬と賛美を込めて、コンピュータの中に住む妖精に捧げます。 “コンピュータサイエンスに関わる私たちにとって、コンピューティングを楽しむことはとても大事だと私は思っています。コンピューティングの始まりの時期には、それはとても楽しいことでした。ご存じの通り、お金を払うお客様たちが騙されるということがそこかしこで起こり、それからしばらくして、私たちは彼らの不満を真面目に受け取るようになりました。私たちは、あたかもコンピュータをきちんとエラーなしで完璧に使えるようにすることが私たちの責任であるかのように考え始めてしまいました。私はそうは思いません。私たちは、コンピュータを発展させ、新しい方向に向かわせ、家の中で楽しめるようにしておくことに責任があると思います。コンピュータサイエンスのその分野が、ずっとその楽しさの感覚を失わないでくれればと願っています。特に、私たちが伝道師になったりしないことを望んでいます。聖書のセールスマンのような感覚を持たないでください。そんな人たちは、もう世界に十分すぎるほどいます。あなたがコンピューティングについて知っていることは、ほかの人たちも学ぶことができます。コンピューティングをうまくやる鍵が、あなたの手の中にしかないとは思わないでください。あなたの手の中にあるものは知性だと、私は思い、またそうであることを願っています。それはつまり、あなたが出会ったマシンに対して、出会ったときよりも多くのものを見ることができる能力です。そして、それをそれ以上のものにできる能力です。” ---Alan J. Perlis (April 1, 1922 -- February 7, 1990) "},"Preface_to_the_Second_Edition.html":{"url":"Preface_to_the_Second_Edition.html","title":"第二版~序文","keywords":"","body":"第二版~序文 ソフトウェアが、ほかの何にも似ていないということはあるでしょうか。それは捨てられるためのもので、常にシャボン玉のように見ることがすべてだと。 ---Alan J. Perlis この本で扱われている題材は、1980年からMITの入門レベルの計算機科学科目の基礎となってきました。初版が発売されたとき、すでにこの教材を使った授業を4年間行っていました。この第二版が出てくるまでには、それからさらに12年が過ぎています。私たちの成果が広く受け入れられ、ほかのテキストにも取り込まれていることについて、私たちはうれしく思っています。私たちは、学生たちがこの本に出てくる考え方やプログラムを身につけ、それらを新しいコンピュータシステムやコンピュータ言語の核として組み込むのを見てきました。古代のタルムードに出てくる言葉遊びを文字通り実現し、私たちの学生は建築者になったのです。このような有能な学生、功績ある建築者を得ることができたのは幸運なことでした。 この版の準備にあたって、何百にものぼるわかりやすい説明を取り込みました。それらは、私たち自身の教育経験や、MITやほかの場所の同僚たちのコメントから得られたものです。この本に出てくる主なプログラミングシステムのほとんどを再設計しました。それには一般計算システム、インタプリタ、レジスタマシンシミュレータ、コンパイラが含まれます。さらに、プログラムの例をすべて書き換え、IEEE Scheme標準(IEEE 1990)に適合したScheme実装であればどんなものの上でもコードを実行できるようにしました。 この版では、いくつかの新しいテーマに重点を置いています。これらの中で最も重要なものは、計算モデルの中で時間を扱うさまざまなアプローチの中心的な役割を果たしているものです。それらのアプローチには、状態つきのオブジェクト、並行プログラミング、関数型プログラミング、遅延評価、非決定性プログラミングがあります。並行性と非決定性については新たに節を設け、本全体を通してこのテーマを統合させるよう力を尽くしました。 この本の初版は、MITの半期の科目のシラバスをなぞったものでした。第二版では、多くの新しい題材を含めたため、半期ですべてをカバーするのは無理でしょう。ですので、講師は教えるべき内容を選ぶ必要があります。私たち自身が講義をする際には、時々論理プログラミング(4.4節)を飛ばします。学生にはレジスタマシンのシミュレータを使わせますが、その実装(5.2節)はやりません。そして、コンパイラ(5.5節)はざっと概要を見るだけです。それでもなお、これは中身の濃い授業です。講師によっては、最初の3章か4章だけをやって、残りの題材は次の科目に譲りたいという人もいるでしょう。 World-Wide-Webサイト http://mitpress.mit.edu/sicp は、この本の読者に対するサポートを提供しています。それには、この本に出てくるプログラム、プログラミング練習問題のサンプル、補助教材、ダウンロード可能なLispのScheme方言の実装が含まれます。 "},"Preface_to_the_First_Edition.html":{"url":"Preface_to_the_First_Edition.html","title":"第一版~序文","keywords":"","body":"第一版~序文 コンピュータはバイオリンのようなものです。次のような場面を想像してみてください。ある初心者の人が、まず蓄音機を動かしてみて、それから次にバイオリンを触ってみます。その人は、バイオリンの音はひどいと言います。人間主義者たちや多くの計算機科学者から私たちが聞く話はそういったものです。コンピュータのプログラムは特定の目的にはよいが、柔軟ではないと。バイオリンやタイプライターだってそんなものです。使い方を学ばなければの話ですが。 ---Marvin Minsky, “Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas” “The Structure and Interpretation of Computer Programs”(SICP, 計算機プログラムの構造と解釈)はマサチューセッツ工科大学(MIT)での入門者レベルの計算機科学の科目です。MITで電気工学や計算機工学を専攻する学生はすべて、4つある“共通コアカリキュラム”のひとつとして履修しなければなりません。残りは、回路と線形システムについての科目2つと、デジタルシステム設計の科目ひとつです。私たちは、この科目の開発に1978年から携わってきました。そして、1980年の秋からは、この教材の現在の形で毎年600人から700人の学生を教えてきています。ほとんどの学生はコンピュータについてそれまでまったく秩序立ったトレーニングを受けていないか、受けていてもわずかなものでした。とはいえ、コンピュータでちょっと遊んだことのある学生は多くいましたし、プログラミングやハードウェア設計に相当な経験のある学生も数人はいましたが。 私たちがこの計算機科学の入門科目の授業計画を策定するにあたって、二つの懸念点を内容に反映させました。一つ目は、コンピュータ言語はただコンピュータに操作を実行させる方法であるにとどまらず、方法論についての考え方を表現するための今までにない形式的媒体であるという考え方を打ち立てたいということでした。ですから、プログラムは人間が読めるように書かなくてはならず、それがたまたま機械によって実行できるというだけのことです。二つ目は、私たちがこのレベルの科目で扱われるべき中心的な題材について信じていることです。教えるべきはことは、特定のプログラミング言語の文法ではなく、また特定の関数を計算するための賢いアルゴリズムでもなく、さらに言うとアルゴリズムの数学的解析やコンピューティングの基礎ですらなく、重要なのは大きなソフトウェアシステムの知的複雑性をコントロールする技術であるということです。 私たちの目標は、この科目を修了した学生たちが、プログラミングのスタイルと美学について、基礎的な感覚を十分に身につけてくれることです。学生たちが、大きなシステムの複雑性をコントロールするための主要な技術を使いこなせるようになること。模範的なスタイルで書かれていれば、50ページにわたるプログラムでも読めるようになっていること。どんなときにも、何を読むべきでないか、何を理解しないでもいいかを判断できるようになること。また、プログラムを変更するにあたって、自信を持って、元の作者の意図とスタイルを保ったままで変更を加えることができるようになっていること。 これらのスキルは、決してコンピュータプログラミングに特有のものではありません。私たちが教え、また利用する技術は、すべての工学的設計に共通するものです。私たちは、詳細な部分を隠す抽象化を適宜加えることによって、複雑性をコントロールします。私たちは、共通のインターフェイスを確立し、標準的かつ中身のよくわかっている部品を「うまく組み合わせる」やり方で、複雑性をコントロールします。私たちは、設計を記述するためにさまざまな言語を作り出し、それぞれの言語が設計のある特定の側面を際立たせ、それ以外の側面を目立たなくさせることによって、複雑性をコントロールします。 私たちのこの科目に対するアプローチの底にあるものは、“計算機科学”は科学ではなく、その意義はコンピュータとほとんど関係がないという信念です。コンピュータ革命とは、私たちの考え方と、考えを表現するやり方の革命です。この変化を象徴する出来事は、手続き的認識論(procedural epistemology)---古典的な数学的テーマで取られるような宣言的な見方ではなく、命令的な見方による知識構造の研究---の出現でしょう。数学は、“何であるか”という考えについて正確に扱う枠組みを提供します。計算機科学は、“どうやるか”という考えについて正確に扱う枠組みを提供します。 この教材では、プログラミング言語Lispのひとつの方言を使います。言語を正式に教えることはしません。その必要がないからです。普通に使っていくだけで、数日のうちに学生は身につけます。これはLisp系の言語の大きな利点です。複合式を作るやり方は少ししかなく、構文構造はあってないようなものです。形式的な性質はすべて、チェスのルールのように、一時間もあればカバーできます。少ししたら、言語の構文的な詳細について忘れてしまい(元からそんなものはないので)、実際の問題---何を計算したいのか、どうやって問題を扱えるサイズの部品に分解するか、それらの部品をどのように作っていくか---に取り組むことになります。もうひとつのLispの利点は、私たちの知る限りほかのどんな言語よりも、プログラムをモジュールに分解する大規模な戦略をサポートしてくれる(しかし強制はしない)というところです。手続きやデータによる抽象化をしたり、よくある使い方のパターンを捉えるために高階関数を使ったり、代入とデータ変更によって局所状態をモデル化したり、ストリームと遅延評価によってプログラムの部品同士を連携させたりといったことが可能です。さらに、組み込み言語の実装も簡単にできます。また、これらすべては、漸進的なプログラム設計、構築、テスト、デバッグに対する優れたサポートを提供する対話的環境に埋め込まれています。これまでにないパワーと優美さを備えたすばらしいツールを作り上げたJohn McCarthyをはじめ、これまでのすべての世代のLispウィザードたちに感謝の気持ちを捧げます。 私たちが使うLispの方言であるSchemeは、LispとAlgolのパワーと優美さをひとつにまとめようとしたものです。Lispからは、シンプルな構文によるメタ言語的なパワー、プログラムをデータオブジェクトとして表す統一的なやり方、ガベージコレクションつきヒープへのデータ割り当てが取り込まれています。Algolからは、レキシカルスコープとブロック構造を取り込んでいます。これらは、Algol委員会のプログラミング言語設計の先駆者たちからの贈り物です。チャーチのλ計算とプログラミング言語の構造との間の関係についての洞察はJohn ReynoldsとPeter Landinによるものです。また、コンピュータが世界に現れる何十年も前からこの領域を探索してきた数学者たちに対する恩義も感じています。彼ら開拓者たちには、Alonzo Church, Barkley Rosser, Stephen Kleene, Haskell Curryなどが含まれます。 "},"1_Building_Abstractions_with_Procedures.html":{"url":"1_Building_Abstractions_with_Procedures.html","title":"1 手続きを用いた抽象化の構築","keywords":"","body":"1 手続きを用いた抽象化の構築 心が単純な考えについてその力を発揮する活動は、主に次の3つです。1. 単純な考えをひとつの合成物に組み合わせること。すべての複雑な考えはこれによってできています。2. 二番目は、単純なものでも複雑なものでも、二つの考えをひとつの場所に並べて置き、それらをひとつに結合することなしに同時に眺めることです。これによって、心は関係性についての考えを得ることができます。3. 三番目は、その考えの実在に伴うほかのすべての考えから、その考えを切り離すことです。これは抽象化と呼ばれ、これによってすべての一般概念というものはできています。 ---John Locke, An Essay Concerning Human Understanding (1690) 私たちは、計算プロセス(computational process)について学ぼうとしています。計算プロセスというのは抽象的な存在で、コンピュータの中に生息しています。それらが進化するにつれ、プロセスはデータ(data)と呼ばれるまた別の抽象物を操作します。プロセスの進化は、プログラム(program)と呼ばれる規則のパターンによって指揮されています。プログラムを作るのは、プロセスを指揮するためです。事実上、私たちは呪文を使ってコンピュータの精霊に魔法をかけているのです。 計算プロセスは、魔法使いの言葉で言うと、精霊のようなものです。それは、見たり触れたりすることはできません。そもそも、物質によって作られていないのです。それでも、それはとてもリアルな存在です。計算プロセスは、知的な作業を行うことができます。質問に答えることができます。銀行のお金を支出したり、工場でロボットの腕を操作したりすることで、世界に影響を与えることもできます。私たちがプロセスに魔法をかけるのに使うプログラムとは、魔法使いの呪文のようなものです。それは難解で深遠なプログラミング言語(programming language)による記号的表現によって慎重に組み立てられ、プロセスに実行させたいタスクを指示します。 計算プロセスは、正しく動くコンピュータでは、プログラムを正確かつ精密に実行します。そのため、魔法使いの見習いのように、初心者プログラマは魔法のもたらす結果を理解し、予測することを学ばなければいけません。プログラムのほんの小さな間違い(普通、バグ(bug)やグリッチ(glitch)と呼ばれます)も、複雑な予期しない結果を引き起こすことがあるのです。 運のいいことに、プログラムを学ぶことは魔法を学ぶことに比べるとずっと安全です。私たちが扱う精霊は、都合のいいことに安全な方法で封じ込まれているからです。しかし、現実世界のプログラミングでは、注意力や専門知識や知恵が必要となります。例えば、CAD(コンピュータによる設計支援)プログラムの小さなバグが、飛行機やダムの破滅的な崩壊を引き起こしたり、産業ロボットの自己破壊を起こしたりするのです。 達人ソフトウェアエンジニアは、プログラムを構築する能力があり、結果となるプロセスが意図するタスクを実行してくれることにある程度自信を持つことができます。彼らは、システムの動作を前もって思い描くことができます。プログラムを構造化して、予期しない問題が破滅的な結果を引き起こさないようにする方法を知っています。そして、問題が起こってしまったときには、プログラムをデバッグ(debug)できます。うまく設計されたコンピュータシステムは、うまく設計された自動車や原子炉のように、モジュール化して設計されていて、部品が別々に作成、置き換え、デバッグできるようになっています。 Lispプログラミング プロセスを記述するのには、適切な言語が必要です。この目的のために、私たちはプログラミング言語Lispを使うことにします。私たちの日々の考えが普通自然言語(英語やフランス語や日本語など)によって表現されるように、そして定量的な現象の記述が数学的記法によって表現されるように、私たちの手続き的な思考はLispによって表現されます。Lispは1950年代の後半に、再帰方程式(recursion equation)と呼ばれるある種の論理表現についての推論を定式化するものとして発明されたものです。この言語はJohn McCarthyにより考え出され、彼の論文“記号式の再帰方程式とそれらの機械による演算”(McCarthy 1960)に基づいています。 数学的な定式化としての生まれにもかかわらず、Lispは実用的なプログラミング言語です。Lispインタプリタ(interpreter)はLisp言語によって記述されたプロセスを実行する機械です。最初のLispインタプリタは、MIT研究所の人工知能部門の同僚、学生に手伝ってもらいながら、McCarthyが実装したものです。1Lispという名前はLISt Processing(リスト処理)の頭文字で、この言語は記号微分や代数式の積分のようなプログラミング上の問題に取り組むための記号操作能力を提供するために設計されたものです。この目的のために、アトムとリストとして知られる新しいデータオブジェクトを導入しています。この特徴が、Lispがその時代のほかの言語から際立ったものとなっている最大の特徴です。 Lispは、一致協力した設計の努力によってできたものではありません。ユーザーの必要とすることや実用的な実装の検討事項に応えるものとして、実験的なやり方で非公式に進化してきたものです。Lispの非公式な進化は何年も続き、Lispユーザーのコミュニティは伝統的に、この言語の“公式な”定義を公布しようとすることに抵抗してきました。この進化が言語の柔軟性と元々のエレガントさと組み合わさって、広く使われている言語としては二番目に古い(これより古いのはFortranだけです)言語であるLispはずっと適応を続け、プログラム設計についての最新の考え方を含むようになっています。そのため、今ではLispは方言の集まりで、元々の特徴の多くを共通して持ちながらも、それぞれ大きく違うこともあるものとなっています。この本で使う方言はSchemeと呼ばれるものです。2 実験的な性質を持ち、また記号操作に重点を置いているため、初期のLispは数値計算については、非常に非効率的なものでした。少なくとも、Fortranと比べるとそうでした。しかし、年を経るにつれ、プログラムを機械語に変換して、十分効率的に数値計算を実行できるようにするLispコンパイラが開発されるようになりました。それに、特別な応用に対しては、Lispは非常に有効に使われています。3今でもLispは、絶望的に非効率的だという昔からの評判を乗り越えられていませんが、今ではLispは効率が最優先事項ではない数多くの応用に使われています。例えば、LispはOSのシェル言語や、エディタやCADシステムの拡張言語として選ばれるものになっています。 Lispがメインストリームの言語でないとしたら、なぜそれをプログラミングの考察のための枠組みとして使うのでしょうか。それは、この言語が独特な特徴を持っているため、プログラミングの重要な構成とデータ構造について学び、それらを支える言語的特性と結びつけるのにとても便利な媒体だからです。これらの特性の中でも最も意義深いものは、プロセスのLispによる記述(これは手続き(procedure)と呼ばれます)が、それ自身Lispのデータとして表され、操作できるということです。これが重要なのは、“受動的な”データと“能動的な”プロセスという伝統的な区別を曖昧にする能力を使った強力なプログラム設計のテクニックが存在するからです。これから見ていくように、Lispは手続きをデータとして扱う柔軟性のおかげで、これらのテクニックを探求するのに最も便利な言語のひとつになっています。手続きをデータとして表現する能力は、コンピュータ言語を支えるインタプリタやコンパイラのような、ほかのプログラムをデータとして操作しなければならないプログラムを書くのにも、Lispをとても優れたものにしています。それに、こういったことを考えに入れなくても、Lispでのプログラミングは本当に楽しいのです。 1. Lisp 1 Programmer's Manualは1960年に登場し、Lisp 1.5 Programmer's Manual (McCarthy et al. 1965)は1962年に出版されました。Lispの初期の歴史は、McCarthy 1978で説明されています。 ↩ 2. 1970年代に主要なLispプログラムの大部分に用いられた2つの方言は、MITのプロジェクトMACで開発されたMacLisp (Moon 1978; Pitman 1983)と、Bolt Beranek and Newman Inc.とXerox Palo Alto研究センターで開発されたInterlisp (Teitelman 1974)でした。Portable Standard Lisp (Hearn 1969;Griss 1981)、異なるマシンの間で簡単に移植できるように設計されたLisp方言です。MacLispは、カリフォルニア大学バークレー校で開発されたFranz Lispや、MIT人工知能研究所がLispをとても効率よく実行できるよう設計した特定目的プロセッサ(処理器)に基づくZetalisp (Moon and Weinreb 1981)といった、いくつかの下位方言を生みました。この本で使用するLisp方言はSheme(Steele and Sussman 1975)と呼ばれ、1975年にMIT人工知能研究所のGuy Lewis Steele Jr.とGerald Jay Sussmanにより開発され、のちにMITで教育目的で再実装されたものです。Common Lisp方言(Steele 1982, Steele 1990)は、初期のLisp方言の機能を組み合わせ、Lispの業界標準を作るためにLispコミュニティにより開発されました。Common Lispは1994年にANSI標準(ANSI 1994)になりました。 ↩ 3. そのような特別な応用のひとつは、自然科学的に重要な計算のブレークスルー---太陽系の運動についての積分の精度を二桁近く上げ、太陽系の力学はカオス的であることを示した---でした。この計算は、新しい積分アルゴリズム、専用コンパイラ、そして専用コンピュータによるものですが、これらはすべてLispによって書かれたソフトウェアツールの助けによって実装されたものです。(Abelson et al. 1992; Sussman and Wisdom 1992) ↩ "},"1.1_The_Elements_of_Programming.html":{"url":"1.1_The_Elements_of_Programming.html","title":"1.1 プログラミングの要素","keywords":"","body":"1.1 プログラミングの要素 強力なプログラミング言語は、コンピュータにタスクの実行を指示する道具というだけではありません。言語は、私たちがプロセスについて考えをまとめる枠組みとしても役に立ちます。そのため、言語を記述する際には、簡単な考えを組み合わせてより複雑な考えを作るためにその言語が提供する手段に対して特別な注意を払う必要があります。強力な言語は、これを達成するために、3つのメカニズムを持っています。 基本式は、言語に関わる最も単純な実体を表します。 組み合わせ方法は、複合要素をより単純なものから構築する方法です。 抽象化方法は、複合要素に名前をつけ、単体として扱うための方法です。 プログラミングでは、二つの要素を扱います。それは、手続きとデータです(のちに、それらがそんなにはっきり分かれるものでないということがわかってきます)。大雑把に言うと、データは“物”で、私たちが操作したいものです。手続きは、データを操作するための規則を記述したものです。そのため、強力なプログラミング言語はすべて、基本的なデータや基本的な手続きを記述でき、また手続きとデータを組み合わせ、抽象化する方法を備えていなければなりません。 この章では、手続きを構築する規則に焦点を当てるため、単純な数値データのみを扱うことにします。4後の章では、複合データを扱う手続きを構築するのにも、これらの同じ規則が使えるということを見ていきます。 4. 数値を“単純なデータ”と見なすのは白々しいごまかしです。実際のところは、数値の扱いは、どのプログラミング言語でも、非常に落とし穴が多く混乱を招く一面となっています。いくつかの典型的な問題は次のようなものです。コンピュータシステムによっては、2のような整数(integer)と2.71のような実数(real number)を別物として扱います。実数2.00は整数2とは違うのでしょうか。整数に使われる算術演算は、実数に使われるものと同じものでしょうか。6を2で割ると、答えは3でしょうか、それとも3.0でしょうか。どれだけ大きな数値まで表現できるのでしょうか。小数点以下は何桁まで表すのでしょうか。整数の範囲は実数と同じでしょうか。これらの問題の先には、もちろん、丸め誤差や切り捨て誤差に関する問題の山が横たわっています。それは、数値解析の科学そのものです。この本での焦点は大規模プログラム設計であり、数値計算のテクニックではないので、これらの問題は無視することにします。この章での数値演算の例では、非整数の演算では有限の小数点以下の精度を保つ算術演算を使い、そのような場合に使われる通常の丸めの挙動が反映されています。 ↩ "},"References.html":{"url":"References.html","title":"参考文献","keywords":"","body":"参考文献 Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister,Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992. The SupercomputerToolkit: A general framework for special-purpose computing.International Journal of High-Speed Electronics 3(3): 337-361.–› Allen, John. 1978. Anatomy of Lisp. New York: McGraw-Hill. ANSI X3.226-1994. American National Standard for InformationSystems---Programming Language---Common Lisp. Appel, Andrew W. 1987. Garbage collection can be faster than stackallocation. Information Processing Letters 25(4): 275-279.–› Backus, John. 1978. Can programming be liberated from the von Neumann style?Communications of the ACM 21(8): 613-641.–› Baker, Henry G., Jr. 1978. List processing in real time on a serial computer.Communications of the ACM 21(4): 280-293.–› Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise.1982. The Scheme-81 architecture---System and chip. In Proceedings ofthe MIT Conference on Advanced Research in VLSI, edited byPaul Penfield, Jr. Dedham, MA: Artech House. Borning, Alan. 1977. ThingLab---An object-oriented system for buildingsimulations using constraints. In Proceedings of the 5th InternationalJoint Conference on Artificial Intelligence.–› Borodin, Alan, and Ian Munro. 1975. The Computational Complexity ofAlgebraic and Numeric Problems. New York: American Elsevier. Chaitin, Gregory J. 1975. Randomness and mathematical proof.Scientific American 232(5): 47-52.–› Church, Alonzo. 1941. The Calculi of Lambda-Conversion. Princeton,N.J.: Princeton University Press. Clark, Keith L. 1978. Negation as failure. In Logic and Data Bases.New York: Plenum Press, pp. 293-322.–› Clinger, William. 1982. Nondeterministic call by need is neither lazy nor byname. In Proceedings of the ACM Symposium on Lisp andFunctional Programming, pp. 226-234. Clinger, William, and Jonathan Rees. 1991. Macros that work. InProceedings of the 1991 ACM Conference on Principles ofProgramming Languages, pp. 155-162.–› Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973. Un syst`eme decommunication homme-machine en fran\\c{c}ais. Technical report, GroupeIntelligence Artificielle, Universit\\'e d'Aix Marseille, Luminy.–› Cormen, Thomas, Charles Leiserson, and Ronald Rivest. 1990. Introductionto Algorithms. Cambridge, MA: MIT Press. Darlington, John, Peter Henderson, and David Turner. 1982. FunctionalProgramming and Its Applications. New York: Cambridge University Press. Dijkstra, Edsger W. 1968a. The structure of the “THE”multiprogramming system. _Communications of the ACM_11(5): 341-346.–› Dijkstra, Edsger W. 1968b. Cooperating sequential processes. InProgramming Languages, edited by F. Genuys. New York: Academic Press,pp. 43-112.–› Dinesman, Howard P. 1968. Superior Mathematical Puzzles. New York:Simon and Schuster. deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977.AMORD: Explicit control of reasoning. In Proceedings of theACM Symposium on Artificial Intelligence and Programming Languages,pp. 116-125.–› Doyle, Jon. 1979. A truth maintenance system. _Artificial Intelligence_12: 231-272.–› Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National FifthGeneration Project: Introduction, survey, and evaluation. In FutureGeneration Computer Systems, vol. 9, pp. 105-117.–› Feeley, Marc. 1986. Deux approches `a l'implantation du languageScheme. Masters thesis, Universit\\'e de Montr\\'eal.–› Feeley, Marc and Guy Lapalme. 1987. Using closures for code generation.Journal of Computer Languages 12(1): 47-66.–› Feller, William. 1957. An Introduction to Probability Theory and ItsApplications, volume 1. New York: John Wiley \\& Sons. Fenichel, R., and J. Yochelson. 1969. A Lisp garbage collector for virtualmemory computer systems. _Communications of the ACM_12(11): 611-612.–› Floyd, Robert. 1967. Nondeterministic algorithms. JACM,14(4): 636-644.–› Forbus, Kenneth D., and Johan deKleer. 1993. Building ProblemSolvers. Cambridge, MA: MIT Press. Friedman, Daniel P., and David S. Wise. 1976. CONS should notevaluate its arguments. In Automata, Languages, and Programming: ThirdInternational Colloquium, edited by S. Michaelson and R. Milner, pp. 257-284.–› Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.Essentials of Programming Languages. Cambridge, MA: MITPress/ McGraw-Hill. Gabriel, Richard P. 1988. The Why of Y. _Lisp Pointers_2(2): 15-25.–› Goldberg, Adele, and David Robson. 1983. Smalltalk-80: The Language andIts Implementation. Reading, MA: Addison-Wesley.–› Gordon, Michael, Robin Milner, and Christopher Wadsworth. 1979.Edinburgh LCF. Lecture Notes in Computer Science, volume 78. New York:Springer-Verlag. Gray, Jim, and Andreas Reuter. 1993. Transaction Processing: Concepts andModels. San Mateo, CA: Morgan-Kaufman. Green, Cordell. 1969. Application of theorem proving to problem solving. InProceedings of the International Joint Conference on ArtificialIntelligence, pp. 219-240.–› Green, Cordell, and Bertram Raphael. 1968. The use of theorem-provingtechniques in question-answering systems. In Proceedings of theACM National Conference, pp. 169-181.–› Griss, Martin L. 1981. Portable Standard Lisp, a brief overview. UtahSymbolic Computation Group Operating Note 58, University of Utah. Guttag, John V. 1977. Abstract data types and the development of datastructures. Communications of the ACM 20(6): 396-404.–› Hamming, Richard W. 1980. Coding and Information Theory. EnglewoodCliffs, N.J.: Prentice-Hall. Hanson, Christopher P. 1990. Efficient stack allocation for tail-recur-sivelanguages. In Proceedings of ACM Conference on Lisp andFunctional Programming, pp. 106-118.–› Hanson, Christopher P. 1991. A syntactic closures macro facility. LispPointers, 4(3).–› Hardy, Godfrey H. 1921. Srinivasa Ramanujan. Proceedings of the LondonMathematical Society XIX(2). Hardy, Godfrey H., and E. M. Wright. 1960. An Introduction to theTheory of Numbers. 4th edition. New York: Oxford University Press.–› Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. IBMSystems Journal 7(2): 74-84. Hearn, Anthony C. 1969. Standard Lisp. Technical report AIM-90,Artificial Intelligence Project, Stanford University.–› Henderson, Peter. 1980. Functional Programming: Application andImplementation. Englewood Cliffs, N.J.: Prentice-Hall. Henderson, Peter. 1982. Functional Geometry. In Conference Record of the1982 ACM Symposium on Lisp and Functional Programming, pp. 179-187.–›,2002 version –› Hewitt, Carl E. 1969. PLANNER: A language for provingtheorems in robots. In Proceedings of the International JointConference on Artificial Intelligence, pp. 295-301.–› Hewitt, Carl E. 1977. Viewing control structures as patterns of passingmessages. Journal of Artificial Intelligence 8(3): 323-364.–› Hoare, C. A. R. 1972. Proof of correctness of data representations.Acta Informatica 1(1). Hodges, Andrew. 1983. Alan Turing: The Enigma. New York: Simon andSchuster. Hofstadter, Douglas R. 1979. Gödel, Escher, Bach: An Eternal GoldenBraid. New York: Basic Books. Hughes, R. J. M. 1990. Why functional programming matters. In ResearchTopics in Functional Programming, edited by David Turner. Reading, MA:Addison-Wesley, pp. 17-42.–› IEEE Std 1178-1990. 1990. IEEE Standard for theScheme Programming Language. Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted byM. Lind, Herbert Kanner, and Robert Floyd. 1960. THUNKS: A way ofcompiling procedure statements, with some comments on procedure declarations.Unpublished manuscript. (Also, private communication from Wallace Feurzeig.) Kaldewaij, Anne. 1990. Programming: The Derivation of Algorithms. NewYork: Prentice-Hall. Knuth, Donald E. 1973. Fundamental Algorithms. Volume 1 of TheArt of Computer Programming. 2nd edition. Reading, MA: Addison-Wesley. Knuth, Donald E. 1981. Seminumerical Algorithms. Volume 2 of TheArt of Computer Programming. 2nd edition. Reading, MA: Addison-Wesley. Kohlbecker, Eugene Edmund, Jr. 1986. Syntactic extensions in the programminglanguage Lisp. Ph.D. thesis, Indiana University.–› Konopasek, Milos, and Sundaresan Jayaraman. 1984. The TK!Solver Book: AGuide to Problem-Solving in Science, Engineering, Business, andEducation. Berkeley, CA: Osborne/McGraw-Hill. Kowalski, Robert. 1973. Predicate logic as a programming language. Technicalreport 70, Department of Computational Logic, School of ArtificialIntelligence, University of Edinburgh.–› Kowalski, Robert. 1979. Logic for Problem Solving. New York:North-Holland.–› Lamport, Leslie. 1978. Time, clocks, and the ordering of events in adistributed system. Communications of the ACM 21(7): 558-565.–› Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek.1981. Report on the programming language Euclid. Technical report, ComputerSystems Research Group, University of Toronto.–› Landin, Peter. 1965. A correspondence between Algol 60 and Church's lambdanotation: Part I. Communications of the ACM 8(2): 89-101. Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector basedon the lifetimes of objects. _Communications of the ACM_26(6): 419-429.–› Liskov, Barbara H., and Stephen N. Zilles. 1975. Specification techniques fordata abstractions. _IEEE Transactions on Software Engineering_1(1): 7-19.–› McAllester, David Allen. 1978. A three-valued truth-maintenance system. Memo473, MIT Artificial Intelligence Laboratory.–› McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551,MIT Artificial Intelligence Laboratory.–› McCarthy, John. 1960. Recursive functions of symbolic expressions and theircomputation by machine. _Communications of the ACM_3(4): 184-195.–› McCarthy, John. 1963. A basis for a mathematical theory of computation. InComputer Programming and Formal Systems, edited by P. Braffort andD. Hirschberg. North-Holland.–› McCarthy, John. 1978. The history of Lisp. In Proceedings of theACM SIGPLAN Conference on the History of ProgrammingLanguages.–› McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I. Levin.1965. Lisp 1.5 Programmer's Manual. 2nd edition. Cambridge, MA:MIT Press.–› McDermott, Drew, and Gerald Jay Sussman. 1972. Conniver reference manual.Memo 259, MIT Artificial Intelligence Laboratory.–› Miller, Gary L. 1976. Riemann's Hypothesis and tests for primality.Journal of Computer and System Sciences 13(3): 300-317.–› Miller, James S., and Guillermo J. Rozas. 1994. Garbage collection is fast,but a stack is faster. Memo 1462, MIT Artificial IntelligenceLaboratory.–› Moon, David. 1978. MacLisp reference manual, Version 0. Technical report,MIT Laboratory for Computer Science.–› Moon, David, and Daniel Weinreb. 1981. Lisp machine manual. Technicalreport, MIT Artificial Intelligence Laboratory.–› Morris, J. H., Eric Schmidt, and Philip Wadler. 1980. Experience with anapplicative string processing language. In Proceedings of the 7th AnnualACM SIGACT/SIGPLAN Symposium on the Principles ofProgramming Languages. Phillips, Hubert. 1934. The Sphinx Problem Book. London: Faber andFaber. Pitman, Kent. 1983. The revised MacLisp Manual (Saturday evening edition).Technical report 295, MIT Laboratory for Computer Science.–› Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.Journal of Number Theory 12: 128-138. Raymond, Eric. 1993. The New Hacker's Dictionary. 2nd edition.Cambridge, MA: MIT Press.–› Raynal, Michel. 1986. Algorithms for Mutual Exclusion. Cambridge, MA:MIT Press. Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A dialect of Lisp or,lambda: The ultimate software tool. In Conference Record of the 1982ACM Symposium on Lisp and Functional Programming, pp. 114-122.–› Rees, Jonathan, and William Clinger (eds). 1991. The ( \\rm revised^4 ) report on thealgorithmic language Scheme. Lisp Pointers, 4(3).–› Rivest, Ronald, Adi Shamir, and Leonard Adleman. 1977. A method for obtainingdigital signatures and public-key cryptosystems. Technical memo LCS/TM82,MIT Laboratory for Computer Science.–› Robinson, J. A. 1965. A machine-oriented logic based on the resolutionprinciple. Journal of the ACM 12(1): 23. Robinson, J. A. 1983. Logic programming---Past, present, and future.New Generation Computing 1: 107-124. Spafford, Eugene H. 1989. The Internet Worm: Crisis and aftermath.Communications of the ACM 32(6): 678-688.–› Steele, Guy Lewis, Jr. 1977. Debunking the “expensive procedure call” myth.In Proceedings of the National Conference of the ACM,pp. 153-62.–› Steele, Guy Lewis, Jr. 1982. An overview of Common Lisp. InProceedings of the ACM Symposium on Lisp and FunctionalProgramming, pp. 98-107. Steele, Guy Lewis, Jr. 1990. Common Lisp: The Language. 2nd edition.Digital Press.–› Steele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975. Scheme: An interpreterfor the extended lambda calculus. Memo 349, MIT ArtificialIntelligence Laboratory.–› Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin,Richard M. Stallman, and Geoffrey S. Goodfellow. 1983. The Hacker'sDictionary. New York: Harper \\& Row.–› Stoy, Joseph E. 1977. Denotational Semantics. Cambridge, MA:MIT Press. Sussman, Gerald Jay, and Richard M. Stallman. 1975. Heuristic techniques incomputer-aided circuit analysis. IEEE Transactions on Circuitsand Systems CAS-22(11): 857-865.–› Sussman, Gerald Jay, and Guy Lewis Steele Jr. 1980. Constraints---A languagefor expressing almost-hierachical descriptions. AI Journal 14: 1-39.–› Sussman, Gerald Jay, and Jack Wisdom. 1992. Chaotic evolution of the solarsystem. Science 257: 256-262.–› Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Microplannerreference manual. Memo 203A, MIT Artificial Intelligence Laboratory.–› Sutherland, Ivan E. 1963. SKETCHPAD: A man-machine graphicalcommunication system. Technical report 296, MIT Lincoln Laboratory.–› Teitelman, Warren. 1974. Interlisp reference manual. Technical report, XeroxPalo Alto Research Center.–› Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data typespecification: Parameterization and the power of specification techniques. InConference Record of the Tenth Annual ACM Symposium on Theoryof Computing, pp. 119-132. Turner, David. 1981. The future of applicative languages. InProceedings of the 3rd European Conference on Informatics, Lecture Notesin Computer Science, volume 123. New York: Springer-Verlag, pp. 334-348. Wand, Mitchell. 1980. Continuation-based program transformation strategies.Journal of the ACM 27(1): 164-180.–› Waters, Richard C. 1979. A method for analyzing loop programs.IEEE Transactions on Software Engineering 5(3): 237-247. Winograd, Terry. 1971. Procedures as a representation for data in a computerprogram for understanding natural language. Technical report AI TR-17,MIT Artificial Intelligence Laboratory.–› Winston, Patrick. 1992. Artificial Intelligence. 3rd edition. Reading,MA: Addison-Wesley. Zabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministicLisp with dependency-directed backtracking. AAAI-87,pp. 59-64.–› Zippel, Richard. 1979. Probabilistic algorithms for sparse polynomials.Ph.D. dissertation, Department of Electrical Engineering and Computer Science,MIT. Zippel, Richard. 1993. Effective Polynomial Computation. Boston, MA:Kluwer Academic Publishers. "},"Foreword.html":{"url":"Foreword.html","title":"前書き","keywords":"","body":"前書き 教育者、将軍、栄養士、精神分析医、そして両親は、計画を立て(program)ます。軍隊や学生は計画によって動いていますし、計画によって動いている社会もあります。大きな課題に取り組むときにはいくつもの計画を使いますが、それらのほとんどは問題に取り組む中で生まれるものです。それらの計画には、そのとき取り組んでいる課題に特化しているように見える問題があふれています。計画を立てるということ自体を知的な活動として理解するためには、コンピュータプログラミングに目を向ける必要があります。コンピュータプログラムを読み書きする必要があります---それも、大量に。何のプログラムか、どういう応用のためかというところはあまり重要ではありません。重要なのは、それらがどのようにふるまい、またより大きなプログラムを作る中でそれらがどれだけスムーズにほかのプログラムと協調できるかということです。プログラマは、部品の完全性と、組み合わせたものの妥当性の、両方を追求しなければいけません。この本では、“プログラム”というのは、Lispのある方言で書かれた、デジタルコンピュータ上で実行されることを前提としたプログラムの作成・実行・研究に焦点を当てています。Lispを使うことは、プログラムの記述について制約を加えるだけで、何をプログラムするかを制約するものではありません。 この本の主題について考えるうえで、3つの事象を考えることになります。人間の心、コンピュータプログラムの集合、そしてコンピュータです。コンピュータプログラムはすべて、実際のプロセスや精神的なプロセスのモデルであり、人間の心の中で生まれるものです。これらのプロセスは、人間の経験と思考から浮かび上がってくるもので、数はとても多く、細かいところまで入り組んでいて、いつでも部分的に理解することしかできません。それらがコンピュータプログラムとして永遠に満足できるようにモデル化されるなんていうことは、めったにありません。ですから、私たちのプログラムは、注意深く工夫されたばらばらの記号の集合であり、絡まり合う関数の組み合わせでありながらも、絶えず進化していきます。私たちのモデルに対する理解が深まったり、広がったり、一般化したりするたびに、私たちはプログラムに手を加えていきます。最終的に、モデルは準安定状態に達し、それは私たちが取り組む別のモデルの中に位置を占めることになります。コンピュータプログラミングに関する興奮の源は、プログラムとして表現されたメカニズムが私たちの心の中とコンピュータ上で絶え間なく広がっていくことと、またそれが生み出す知覚の爆発です。芸術が私たちの夢を解釈するものだとすると、コンピュータは夢を、プログラムという形で実行するものなのです！ コンピュータは強力ですが、厳しい親方でもあります。プログラムは正しくなければならず、伝えたいことは細かいところまで正確に伝えなければいけません。ほかのすべての記号的な活動と同じく、プログラムが真であることは論証によって知ることができます。Lispはそれ自身、意味論(これもまたモデルです)を割り当てることができ、そしてプログラムの仕様が、例えば述語論理などによって決められるのであれば、論理学の証明方法によって、容認可能な正確性の論証をすることができます。残念ながら、プログラムが大きく複雑になるにつれ(いつもそうなるのですが)、仕様自体の妥当性、一貫性、正しさが疑わしいものになっていきます。そのため、完全な形式的な正しさの論証というものが大きなプログラムについてくるということはめったにありません。大きなプログラムは小さなものから成長していくものなので、正しさについて確信を持てるような標準的なプログラム構造(これをイディオムと呼びます)の武器庫を作り上げ、確立された組織化技術によってより大きな構造に組み立てていく方法を学ぶことが決定的に重要になります。この本では、それらの技術について詳細に扱っていきます。それらを理解することは、プロメテウスのような創造的な営みであるプログラミングという分野に加わるためには不可欠なことです。何よりも、強力な組織化の技術を発見し身につけていくことによって、大規模で重要なプログラムを書くにあたって必要となる能力を育てることができます。また逆に、大規模なプログラムを書くことは負担がとても大きいということもあり、何とか新しい手法を発明して、大規模なプログラムに組み込む関数や実装の量を減らすことができないかと考えていくことになります。 プログラムとは違って、コンピュータは物理法則に従わなければなりません。もし素早く---状態遷移あたり数ナノ秒といったレベルで---動作したければ、電子をほんの短い距離(せいぜい1121{1\\over2}121​ フィートだけ)しか運ぶことができません。空間的にぎっしり詰め込まれた膨大な数のデバイスが発する熱は、取り除く必要があります。高機能性とデバイス密度のバランスを取りながら、精緻な工学的技法が発展してきました。いずれにせよ、ハードウェアは私たちがプログラムしようとしているレベルよりも基礎的なレベルで動いています。私たちのLispのプログラムを“機械の”プログラムに変換する処理は、それ自身が抽象的なモデルで、それは私たちがプログラムするものです。その研究と作成は、どんなモデルをプログラムするときにも関わってくるような組織的プログラムについて、多くの洞察を与えてくれます。もちろん、コンピュータそれ自身もそのようにモデル化されています。考えてみてください。一番小さい物理的なスイッチング素子は量子力学によってモデル化され、量子力学は微分方程式によって記述され、微分方程式の詳細なふるまいは数値近似によって表され、数値近似はコンピュータプログラムによって表現され、そのコンピュータプログラムはコンピュータによって実行され、そのコンピュータを構成する素子は…！ 3つの焦点を別々に設定することは、単なる方法上の便利さのためだけではありません。よく「すべては頭の中のことだ」と言われますが、このように論理的に分けることによって、これらの焦点の間の記号的通信を促進できます。人間の経験の中で、これら3つの豊かさ、生命力、潜在力を超えるものは、人生そのものの発展ぐらいです。これらの焦点の間の関係は、せいぜい準安定状態です。コンピュータの容量の大きさや速さは、これで十分となることは決してありません。ハードウェア技術の進歩のたびに、より大きなプログラミングの取り組み、新しい組織化原則、そして抽象モデルの発展が引き起こされます。読者は、定期的に“どこに向かっているんだ? どこに向かっているんだ?”と自問しなければなりません。---でも、あまり問いすぎないようにしましょう。そうでないと、ほろ苦い哲学的な便秘のたに、プログラミングの楽しさを見逃してしまうことになります。 私たちが書くプログラムの中で、一部のもの(しかし、決して十分にはならない)は、並べ替え、数列の最大値を見つける、素数性判定、平方根の計算といった、精密な数学的な関数を実行します。そのようなプログラムはアルゴリズムと呼ばれ、その最適なふるまいについては多くのこと(特に、実行時間とデータストレージの必要量という二つのパラメータについて)が知られています。プログラマは、よいアルゴリズムとイディオムを身につけなければなりません。プログラムの中には厳密な仕様が記述しにくいものもありますが、プログラマとしては責任を持ってパフォーマンスを推定し、また常に改善しようとしなければなりません。 Lispは、“生き残ったもの”です。約四半世紀にわたって使われてきています。活発なプログラミング言語の中で、これより長い時間を生きてきたものはFortranだけです。どちらの言語も、重要な応用領域でのプログラミングの必要性を支えてきています。Fortranは科学計算と工学計算を支え、Lispは人工知能を支えてきました。この二つの分野は今でも重要であり続け、これらの分野のプログラマはLispとFortranという二つの言語に力を注いでいるので、少なくとももうあと四半世紀の間活発に使われる言語であり続けるということは十分ありうることです。 Lispは変化します。このテキストで使っているScheme方言は、オリジナルのLispから進化してきたもので、いくつかの重要な点で異なっています。例えば、変数束縛のための静的スコーピングや、関数が関数を値として返すことを許可することなどです。構文的な構造において、SchemeはAlgol 60に似ています。その近さは、Schemeと初期のLispとの近さと同じ程度です。Algol 60は、もう活発な言語になることはないでしょうが、SchemeとPascalの遺伝子の中に生き続けています。これら二つの言語ほど、かけ離れた文化に取り囲まれ、その流通貨幣となっているような二つの言語というのもなかなかないでしょう。Pascalはピラミッドを建てるためのものです。雄大で、息をのむような、静的な構造物で、軍隊が重い石を運び、所定の位置に押しこむことによって作られています。Lispは有機体を作るためのものです。雄大で、息をのむような、動的な構造物で、小さなチームが無数のより単純な揺れ動く有機物を所定の位置に入れることによって作られています。どちらの場合にも、組織化のための原則は同じですが、ひとつだけ非常に重要な違いがあります。個々のLispプログラマに委ねられたエクスポート可能な関数は、Pascal企業の中で見つけられるものより桁違いに多いのです。Lispのプログラムは、本来目的としていたアプリケーションを超えた有用性を持つ関数でライブラリをいっぱいにします。そのように有用性が増加していく背景には、リストというLispのネイティブデータ構造の存在があります。リストの単純な構造と自然な適用可能性は、驚くほど普遍的な関数という形で表れてきます。Pascalでは、宣言可能なデータ構造の多さが関数の専門化を引き起こし、気軽な連携は禁じられ、ペナルティを与えられるものとなります。ひとつのデータ構造を扱う100の関数があるほうが、10のデータ構造を扱う10の関数があるのよりもよいのです。結果として、ピラミッドは千年もの間変化せずに存在し続けなければならないのに対し、有機体は存在する限り進化し続けなければなりません。進化を止めるということは滅びることを意味します。 この違いをはっきり知るためには、この本の中での教材と練習問題の扱いを、何でもいいのでPascalを使った入門テキストと比べてみてください。このテキストはMITでしか消化できない、MITに固有の種族のためのものだとかいった妄想は抱かないでください。このテキストは、真面目なLispのプログラミングの本はどのようなものでなければいけないかというところを形にしたものであり、学生が誰であるか、どこで使われるかは関係ありません。 ひとつ気をつけておいていただきたいのは、この本はプログラミングに関するテキストだということです。ほとんどのLispの本は人工知能に使うための準備となっていますが、この本は違います。いずれにしても、対象となるシステムが大きくなるにつれ、ソフトウェア工学と人工知能に関わる重要なプログラミング上の課題は融合していく傾向にあります。まさにそのために、人工知能以外の領域でも、Lispに対してこれほどの関心が向けられているのです。 その目的とするところから予想できる通り、人工知能の研究は数多くの重要なプログラミングの問題を生み出しています。ほかのプログラミング分野であれば、このような大量の問題に対しては新しい言語が生み出されるところです。実際に、非常に大きなプログラミングのタスクにおいて、組織化のために便利な方法のひとつは、新しい言語を発明して、タスクモジュールの中に通信を閉じ込め、コントロールするということです。これらの言語は、私たち人間が頻繁にやりとりを行うシステムの周辺部に近づくにつれて、単純でなくなっていく傾向があります。その結果、そのようなシステムでは、複雑な言語処理の機能が何回も繰り返し実装されることになります。Lispは、非常に単純なシンタックスとセマンティクスを持つため、パージングは初歩的なタスクとして扱うことができます。ですので、パージング技術はLispのプログラムの中でほとんど何の役割も果たしません。また、大きなLispのシステムが成長し変化していく中で、言語処理系の構築がその成長速度の妨げになることはめったにありません。最後になりますが、このシンタックスとセマンティクスの単純さこそが、すべてのLispプログラマが付き合うことになる重荷と自由の源泉になっているのです。数行以上のLispプログラムを書こうとすると、必ず自由に使える関数でいっぱいになります。発明し、組み込み(fit)ましょう。かんしゃくを起こし(have fits)、再発明しましょう！ 括弧のネストの中に自分の考えを書いていくLispプログラマに乾杯。 Alan J. Perlis New Haven, Connecticut "},"Acknowledgments.html":{"url":"Acknowledgments.html","title":"謝辞","keywords":"","body":"謝辞 この本とこのカリキュラムの開発を手助けしてくださった多くの方々に感謝いたします。 私たちの科目は、明らかに“6.231”の知的な系譜を継ぐものです。それは、1960年代後半にMITでJack WozencraftとArthur Evans, Jr.が担当していた、プログラミング言語学とλ計算についてのすばらしい科目でした。 Robert FanoがMITの電気工学と計算機科学の入門カリキュラムを再編成し、工学設計の原理に重点を置くようにしてくれたことに非常に感謝しています。彼はこの取り組みを始めるよう私たちを導き、最初の科目ノートをまとめてくれました。この本は、それをもとに発展してきたものです。 私たちが教えようとしているプログラミングのスタイルと美学は、その多くがGuy Lewis Steele Jr.と連携して開発したものです。彼は、Gerald Jay SussmanとともにScheme言語の初期の開発に携わりました。さらに、David Turner, Peter Henderson,Dan Friedman, David Wise, Will Clingerは、この本に登場する関数プログラミングコミュニティのテクニックを数多く教えてくれました。 Joel Mosesは、大きなシステムを構築する方法を教えてくれました。彼は、記号計算に使われるMacsymaシステムでの開発経験を通して、制御の複雑性を回避して、モデル化しようとしている世界の現実の構造を反映するようデータを体系化することに集中することが重要だということを学んでいました。 Marvin MinskyとSeymour Papertは、プログラミングと、知的生活の中でそれをどのように位置づけるかについて、私たちの姿勢の多くを形作ってくれました。コンピュータがなければ正確に扱うには複雑すぎるような考えを探究するにあたって、コンピュータが表現手段を与えてくれるということを理解できるようになったのは彼らのおかげです。彼らは、学生のプログラムを書き、変更する能力が、自然活動を探究するための強力な方法になると強調しています。 私たちはまた、プログラミングはとても楽しいものであり、プログラミングの楽しみを支えるよう注意しなければいけないというAlan Perlisの考え方に強く同意します。この楽しみの一部分は、偉大な職人たちの働いているところからも得ることができます。Bill GosperやRichard Greenblattのもとで見習いプログラマとして働けたことは幸運なことでした。 私たちのカリキュラムの開発に貢献してくださったすべての方々について名前を挙げるのは困難です。過去15年間私たちと共に働き、私たちの科目に多くの時間を費やしていただいたすべての講師、口頭の指導者、チューターたち、中でもBill Siebert,Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein,Peter Szolovitsに感謝します。現在はウェルズリーにいるFranklyn Turbakに、教育上の際立った貢献について特に感謝します。彼の学部生向けの授業は、私たち皆が目指す基準を打ち立てました。Jerry SaltzerとJim Millerには、私たちが並行性のミステリーに取り組むのを手助けしてくださったことを感謝します。そしてPeter SzolovitsとDavid McAllesterには、第4章における非決定性評価の説明に対する貢献に感謝します。 多くの方々が、他大学でこの資料を紹介するのに大きな努力を費やしてくださいました。中でも私たちが緊密に連携していたのは、イスラエル工科大学のJacob Katzenelson、カリフォルニア大学アーバイン校のHardy Mayer、オックスフォード大学のJoe Stoy、パデュー大学のElisha Sacks、ノルウェー技術科学大学のJan Komorowskiです。私たちは、他大学にこの科目を適合させることで主要な教育の賞を受けた同僚たちを非常に誇りに思います。この中には、イェール大学のKenneth Yip、カリフォルニア大学バークレー校のBrian Harvey、コーネル大学のDan Huttenlocherが含まれます。 Al Moyéは、ヒューレット・パッカードの技術者にこの教材を教え、その講義をビデオテープにすることを手配してくれました。これらのビデオを使った生涯教育のコースを計画し、世界中の大学や企業で教えた有能な講師たち、特にJim Miller, Bill Siebert, Mike Eisenbergに感謝します。 第一版の翻訳には、ほかの国の多くの教育者が多大な労力をつぎ込んでくれました。フランス語版はMichel Briand, Pierre Chamard, André Pic、ドイツ語版はSusanne Daniels-Herold、日本語版は元吉文男氏によって製作されています。中国語版は誰が製作したのかわかりませんが、“無許可”翻訳の題材として選ばれたことを光栄に思います。 私たちが教育目的で使用するSchemeシステムの開発に技術的な貢献をしたすべての方々の名前を挙げることは困難です。Guy Steeleのほかに、主なウィザードにはChris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, Stephen Adamsがいます。ほかに多大な時間を費やしてくれた方々は、Richard Stallman, Alan Bawden,Kent Pitman, Jon Taft, Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee,George Carrette, Soma Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz,Wayne Noss, Todd Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise,Kenneth Sinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin, Ruth Shyu です。 MITの実装を越えて、私たちはIEEEのScheme標準仕様に取り組んでくれた多くの人々に感謝したいと思います。その中にはR⁴RSを編集したWilliam ClingerとJonathan Rees、IEEE標準を準備したChris Haynes, David Bartley,Chris Hanson, Jim Millerが含まれます。 Dan Friedmanは、長い間Schemeコミュニティのリーダーでした。コミュニティの広範な仕事は言語設計の問題を越えて、Schemer's Inc.によるEdSchemeをもとにした高校生向けカリキュラムや、Mike EisenbergやBrian HarveyとMatthew Wrightによるすばらしい本のような、意義深い教育上のイノベーションまで含みます。 私たちは、このコースをちゃんとした本にすることを助けてくれた方々、特にMIT出版のTerry Ehling, Larry Cohen, Paul Bethgeに感謝します。Ella Mazelはすばらしい表紙絵を見つけてくれました。第二版については、特にこの本のデザインを助けてくれたBernardとEllaのMazel夫妻、非凡なTeXTeXTeXウィザードであるDavid Jonesに感謝します。私たちはまた、新しいドラフトに対して洞察力のあるコメントをしてくださった読者の方々、Jacob Katzenelson, Hardy Mayer, Jim Millerに感謝します。そして特にBrian Harveyには、Julieが彼の本Simply Schemeにしたのと同じような貢献を返してくれたことを感謝します。 最後に、この作品を何年にもわたって支持してくれた団体に感謝します。その中には、Ira GoldsteinとJoel Birnbaumが実現してくれたヒューレット・パッカードからの支持と、Bob Kahnが実現してくれたDARPAからの支持を含みます。 "},"1.1.1_Expressions.html":{"url":"1.1.1_Expressions.html","title":"1.1.1 式","keywords":"","body":"1.1.1 式 プログラミングを始める簡単な方法のひとつとして、LispのScheme方言のインタプリタと対話をしてみて、その結果を調べるというやり方があります。コンピュータターミナルの前に座っているところを想像してみてください。あなたが式(expression)を入力すると、インタプリタはその式の評価(evaluation)の結果を表示することによって応答します。 タイプできる基本的な式のひとつとして、数値があります(より正確に言うと、あなたがタイプする式は、10進数の数値を表す数値からなります)。Lispに次の数値を入力すると、 486 インタプリタは以下の内容を表示することで応答します。5 486 数値を表す式は、基本的な手続きを表す式(例えば+\\texttt{+}+ や *\\texttt{*}*)と組み合わせることで複合式を作り、数値に対し手続きを適用することを表します。例えば: (+ 137 349) 486 (- 1000 334) 666 (* 5 99) 495 (/ 10 5) 2 (+ 2.7 10) 12.7 このような式は、括弧の中の式のリストを区切ることにより作られ、手続きの適用を意味するもので、組み合わせ(combination)と呼ばれます。リストの左端の要素は演算子(operator)と呼ばれ、ほかの要素は被演算子(operand)と呼ばれます。組み合わせの値は、演算子によって指定された手続きを、被演算子の値である引数(argument)に適用することによって得られます。 演算子を被演算子の左に置くというやり方は、前置記法(prefix notation)として知られているものですが、数学で慣例となっているやり方とは大幅に違うので、最初は混乱するかもしれません。しかし、前置記法にはいくつかの利点があります。その中のひとつは、任意の数の引数を取る手続きにも対応できるということです。例を以下に示します。 (+ 21 35 12 7) 75 (* 25 4 12) 1200 演算子はいつでも左端の要素で、組み合わせ全体は括弧で区切られているので、曖昧さの入り込む余地はありません。 前置記法の二つ目の利点は、これを単純に拡張して、組み合わせをネストできる、つまり、組み合わせの要素がそれ自身組み合わせであるようなものが作れるということです。 (+ (* 3 5) (- 10 6)) 19 このようなネストや、Lispインタプリタが評価できる式の全体としての複雑性には(原則的には)制限がありません。次のような、まだ比較的単純な式に出会った場合、混乱してしまうのは私たち人間のほうです。 (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) インタプリタは、迷うことなく57だと評価するでしょう。このような式は、次のような形で書くことで、私たち自身にわかりやすいようにできます。 (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) プリティプリント(pretty-printing)として知られるフォーマットの慣習は、被演算子が垂直に揃うようにそれぞれの長い組み合わせを書くというものなのですが、上の式はそれに従って書いたものです。結果として、字下げが明確に式の構造を示すことになります。6 複雑な式でも、インタプリタはいつでも同じ基本的なサイクルで動作します。式を端末から読み、式を評価し、結果を表示するというものです。この操作モードはよく、インタプリタのREPL(read-eval-print loop)モードと呼ばれます。特に、結果を表示することをインタプリタに明示的に指示しなくてもいいというところに注意してください。7 5. この本全体を通して、ユーザーの入力とインタプリタが表示した応答との違いを強調したい場合、後者を斜体で表します。 ↩ 6. Lispシステムは、普通はユーザーが式を整形しやすいようにする機構を持っています。その中でも特に役に立つものが二つあります。ひとつは、改行のタイミングで自動的に正しいプリティプリントの位置にインデントするというもので、もうひとつは右括弧が入力されるたびにマッチする左括弧をハイライトするというものです。 ↩ 7. Lispは、すべての式は値を持つという慣習に従っています。この慣習と、Lispは非効率的な言語であるという昔からの評判を組み合わせて、Alan PerlisはOscar Wildeのセリフをもじった次のような皮肉を言っています。“Lispプログラマはすべての値を知っているが、コストについては何も知らない” ↩ "},"1.1.2_Naming_and_the_Environment.html":{"url":"1.1.2_Naming_and_the_Environment.html","title":"1.1.2 命名と環境","keywords":"","body":"1.1.2 命名と環境 プログラミング言語の重要な特徴のひとつは、コンピュータ上のオブジェクトを指すために名前を利用する手段を提供してくれるということです。このことを、値(value)がそのオブジェクトである変数(variable)を名前によって特定すると言います。 LispのScheme方言では、define\\texttt{define}define(定義)によって対象に名前をつけます。以下のように入力すると、 (define size 2) インタプリタはsize\\texttt{size}sizeという名前と2という値を関連づけます。8size\\texttt{size}sizeという名前が一度2という数値に関連づけられると、2という値を名前によって参照できます。 size 2 (* 5 size) 10 define\\texttt{define}defineの使い方をさらに見ていきましょう。 (define pi 3.14159) (define radius 10) (* pi (* radius radius)) 314.159 (define circumference (* 2 pi radius)) circumference 62.8318 define\\texttt{define}defineは、この言語の持つ抽象化方法のうち、最も単純なものです。これによって、上で計算したcircumference\\texttt{circumference}circumference(円周)のような複合演算の結果を簡単な名前で参照できます。一般的に、コンピュータ上のオブジェクトというものはとても複雑な構造を持っているので、使うたびにその細かいところを思い出して打ち直さないといけないとしたら、とんでもなく面倒なことになります。インタプリタでは、この名前とオブジェクトの関連づけを一連の対話を通して少しずつ作っていくことができるので、このような段階的なプログラムの構築に特に便利です。この特徴は、プログラムの開発・テストを少しずつ進めていくのに向いていて、Lispプログラムが一般的に大量の比較的単純な手続きから構成されるということの大きな理由となっています。 当然のことですが、インタプリタが値と記号を関連づけ、後から取り出すことができるということは、名前とオブジェクトのペアを記録しておくために何らかのメモリを持っておかないといけません。このメモリは環境(environment)と呼ばれます(より正確には、グローバル環境(global environment)です。後で学ぶように、演算には複数の異なる環境が使われることもあるからです)。9 8. この本では、定義を評価した後にインタプリタが返す応答を示すことはしません。それは実装に強く依存するからです。 ↩ 9. 第3章では、インタプリタがどのように動作しているかを理解するため、またインタプリタを実装するために、この環境という概念がキーポイントになることを示します。 ↩ "},"Unofficial_Texinfo_Format.html":{"url":"Unofficial_Texinfo_Format.html","title":"非公式Texinfoフォーマット","keywords":"","body":"非公式Texinfoフォーマット これはSICPの非公式Texinfo版訳注1の第二版です。 あなたはきっと、これをEmacsのInfoモードのようなInfoハイパーテキストブラウザで読んでいるのでしょう。もしかすると、LaTeX\\LaTeXLATE​Xで組版されたものを画面上で、または印刷して読んでいるのかもしれませんね。もっとも、それは間抜けなことだと思いますが。それに、印刷するにはだいぶお金がかかりますよね。 HTML-GIF版は公式に無料で公開されているのですが、それを初めてUnofficial Texinfo Format(非公式Texinfo版、UTF)の初版としてLytha Aythが個人的に変換したのは、2001年4月の長いEmacs Lovefest Weekendの間のことでした。 UTFはHTML版よりも検索が簡単です。また、あまりよくないコンピュータ(例えば寄付された386マシンのようなもの)を使っている人にとってもアクセスしやすいでしょう。 386マシンは、理論的には、Linux、Emacs、Schemeインタプリタを同時に実行できます。 しかし、多くの386マシンでは、Netscapeとそれに必要なX Window Systemの両方を動かそうとすると、まだ始めたてでお金もない若いハッカーにスラッシング(thrashing)という概念を早い段階から教えるはめになるのがオチです。それに、UTF版なら圧縮なしで1.44MBのフロッピーディスクに収まりますので、インターネットやLANへの接続環境のないPCに インストールするのにも便利です。 Texinfoへの変換は、可能な範囲で直接的な翻字をしました。TeX\\TeXTE​XからHTMLへの変換のように、これによってある程度内容が損なわれてしまいました。非公式TexInfo形式では、図はいにしえの技術であるアスキーアートによって不格好に復活させられることになりました。 また、多量の上付き文字(‘ˆ’)と下付き文字(‘_’)を変換するうちに、曖昧さによる変換ミスが含まれてしまった可能性も大いにあります。どれが変換ミスかを当てるのは、読者への課題とします。 しかし、少なくとも私たちは、“より大きい”という記号を&gt;\\texttt{\\&gt;}&gt;と符号化して私たちの勇敢な宇宙飛行士たちを危険にさらすようなことはしていません。 もしあなたがsicp.texi\\texttt{sicp.texi}sicp.texiを変更して間違いを直したりアスキーアートを改善したりした場合、@set utfversion 2.andresraba5.5\\texttt{@set utfversion 2.andresraba5.5}@set utfversion 2.andresraba5.5の行を更新し、あなたの差分を反映してください。 例えば、もしあなたがLythaのバージョン1\\texttt{1}1から始めていて、あなたの名前がBobなら、改訂版には1.bob1\\texttt{1.bob1}1.bob1, 1.bob2\\texttt{1.bob2}1.bob2, …\\dots… , 1.bobn\\texttt{1.bob\\textit{n}}1.bobnのように名前をつけるのがいいでしょう。 また、utfversiondate\\texttt{utfversiondate}utfversiondateも更新してください。もしあなたが自分の改訂版をWeb上で配布したいのなら、文字列“sicp.texi”をファイルやWebページのどこかに埋め込んでおけば、Web検索エンジンから見つけやすくなるでしょう。 非公式Texinfo形式は、寛大にもフリーに配布されているHTML版の魂を引き継いでいると信じられています。しかし、いつどこかの法律家の大艦隊が、何でもないような小さなことをめぐって大騒ぎをしないとも限りません。ですから、あなたのフルネームを使ったり、あなたのアカウント名やマシン名を含むかもしれないInfo, DVI, PostScript, PDF版を配布したりするのは慎重に考えてからにしてください。 Peath, Lytha Ayth 付録:AbelsonとSussmanによるSICPのビデオレクチャーもご覧ください。 MIT CSAIL, MIT OCW. 付録2:上記は2001年の元のUTFの紹介です。 10年後のいま、UTFは一変しました。数学上の記号と式は適切に組版され、図はベクターグラフィックにより描かれています。元のテキスト形式とアスキーアートの図は今でもTexinfoのソースに残っていますが、表示されるのはInfo形式にコンパイルした場合だけです。 電子書籍リーダーとタブレットの夜明け時代になって、画面上でPDFを読むことは、もはや馬鹿馬鹿しいことではないとはっきり言えるようになりました。 楽しんでください！ 訳注1. 英語版にはTexinfo版がありますが、日本語版にはありません。LaTeX\\LaTeXLATE​XソースとPDFのみです。 ↩ "},"1.1.4_Compound_Procedures.html":{"url":"1.1.4_Compound_Procedures.html","title":"1.1.4 複合手続き","keywords":"","body":"1.1.4 複合手続き ここまでで、強力なプログラミング言語であれば必ず持っているようないくつかの要素について、それがLispにもあることを見てきました。 数値は基本データで、算術演算は基本手続きである。 組み合わせをネストすることで、演算を組み合わせることができる。 定義は名前と値を関連づけ、抽象化のためにある程度役に立つ。 ここでは、手続きの定義(procedure definition)について学びます。これははるかに強力な抽象化のテクニックで、複合演算に名前をつけ、それにひとつの単位として参照できるようにするというものです。 まずは、“二乗の計算”とはどのように表現できるかを考えてみましょう。例えば、“何かを二乗するには、その何かにその何か自身をかける”のようになるでしょう。これは、私たちの言語では次のように表すことができます。 (define (square x) (* x x)) これは、次のように理解できます。 (define (square x) (* x x)) | | | | | | 定義 二乗する xを かける xを xで. ここでは、複合手続き(compound procedure)を作り、それにsquare\\texttt{square}squareという名前をつけています。この手続きは、何かにそれ自身をかけるという演算を表しています。かける数にはx\\texttt{x}xという名前をつけていますが、これは自然言語で代名詞が果たすのと同じ役割を果たしています。この定義を評価すると、この複合手続きを作成し、それをsquare\\texttt{square}squareという名前と関連づけています。12 手続き定義の一般形式は以下の通りです。 (define (⟨名前⟩ ⟨仮引数⟩) ⟨本体⟩) ⟨名前⟩は、環境の中で手続きに関連づける記号です。13⟨仮引数⟩は、手続きの本体の中で対応する引数を参照するために使う名前です。⟨本体⟩は、その中に出てくる仮引数をその手続きが適用される実際の引数で置き換えた場合に、手続き適用後の値を返すような式です。14⟨名前⟩と⟨仮引数⟩は、定義する手続きを実際に呼び出すときと同じように、括弧でくくります。 square\\texttt{square}squareを定義したので、もうそれを使うことができます。 (square 21) 441 (square (+ 2 5)) 49 (square (square 3)) 81 square\\texttt{square}squareは、ほかの手続きを定義するための構成部品として使うこともできます。例えば、 x2+y2x^2 + y^2x2+y2は次のように表現できます。 (+ (square x) (square y)) 二つの数値が引数として与えられたときにその二乗の和を求めるsum-of-squares\\texttt{sum-of-squares}sum-of-squaresという手続きも、簡単に定義できます。 (define (sum-of-squares x y) (+ (square x) (square y))) (sum-of-squares 3 4) 25 これで、sum-of-squares\\texttt{sum-of-squares}sum-of-squaresをさらに別の手続きの構成部品として使うこともできるようになります。 (define (f a) (sum-of-squares (+ a 1) (* a 2))) (f 5) 136 複合手続きは、基本手続きとまったく同じように使うことができます。実際、上に書いたsum-of-squares\\texttt{sum-of-squares}sum-of-squaresの定義を見ても、square\\texttt{square}squareが+\\texttt{+}+や*\\texttt{*}*のような組み込み手続きなのか、複合手続きとして定義されたものなのか、見分けることはできないはずです。 12. ここで、二つの異なる操作が組み合わされていることに気をつけてください。まず手続きを作成して、それにsquare\\texttt{square}squareという名前をつけています。手続きを名前をつけずに作るということと、すでに作られている手続きに名前をつけることということの、二つの概念を区別することは可能であり、重要なことでもあります。そのやり方については1.3.2節で見ていきます。 ↩ 13. この本全体を通して、式の一般的な構文について記述する際には、山括弧でくくったイタリックの記号---例えば、⟨name⟩---を使って、それらの式を実際に使うときに埋めなければならない“スロット”を表します。 ↩ 14. もう少し一般化な言い方をすると、手続きの本体は式の列にもなりえます。その場合、インタプリタは列のそれぞれの式を順番に評価し、最後の式の値を手続き適用の値として返します。 ↩ "},"1.1.3_Evaluating_Combinations.html":{"url":"1.1.3_Evaluating_Combinations.html","title":"1.1.3 組み合わせの評価","keywords":"","body":"1.1.3 組み合わせの評価 この章の目標のひとつは、手続き的に考えるうえでの問題点を分解することです。とりあえず、組み合わせを評価するにあたって、インタプリタはそれ自身、手続きに従っているということを考えてみましょう。 組み合わせを評価するため、以下のことを行います。 組み合わせの部分式を評価する 部分式の左端(演算子)の値となっている手続きを、引数(被演算子)、つまり部分式の残り値に適用する こんな単純な規則からも、手続き一般についてのいくつかの重要なポイントがわかります。一つ目のステップは、組み合わせに対する手続きを評価するには、組み合わせのそれぞれの要素に対する評価手続きを先にやらないといけないということを示しています。そのため、評価規則は本質的に再帰的(recursive)なものになります。これは、ステップのひとつとして、その規則自身を呼び出さないといけないということです。10 再帰という考えが、深くネストした複合式をどれだけ簡潔に表現できるかというところに注目してください。再帰がなければ、かなり複雑な手続きになるところです。例えば、次の式の評価する場合について考えます。 (* (+ 2 (* 4 6)) (+ 3 5 7)) この式を評価するには、4つの異なる組み合わせに対して評価規則を適用する必要があります。この手続きは、図1.1のように組み合わせを木の形で表すことによってイメージできます。それぞれの組み合わせはノードとして表され、そこから組み合わせの演算子と被演算子に対応する枝が生えています。終端ノード(そこから生えている枝のないノード)は、演算子か数字を表しています。評価を木という形で見ることで、被演算子の値が終端ノードから始まってそれぞれのレベルで組み合わさりながら上に向かって伝わっていく様子がイメージできます。一般的に、階層的な木のようなオブジェクトを扱うためには、再帰はとても強力なテクニックです。この“値を上に向かって伝える”という形の評価規則は、木の集積(tree accumulation)として知られています。 図1.1: 部分組み合わせの値を示した木表現 次に、一つ目のステップを繰り返して適用することで、ある点で評価する対象が、組み合わせではなく数値や組み込み演算子やその他の名前といった基本式になるというところに注目してください。このような基本的な場合については、以下のように規定することによって扱います。 数字の値は、それが示す値である 組み込み演算子の値は機械語の列で、それに対応する操作を実行する その他の名前の値は、現在の環境でその名前に関連づけられたオブジェクトである 二つ目の規則は、三つ目の規則の特殊なケースと考えることができます。このことは、+\\texttt{+}+と*\\texttt{*}*といった記号もグローバル環境に含まれていて、一連の機械語命令がそれらの“値”として関係づけられていると規定することによって可能になります。ここでキーになるのは、式に出てくる記号の意味を決めるうえで環境の果たす役割です。Lispのような対話的な言語では、(+ x 1)\\texttt{(+ x 1)}(+ x 1)という式の値について考えるのは、x\\texttt{x}xという記号に意味を付与する環境についての情報がなければ意味がありません。+\\texttt{+}+という記号に対しても、意味を付与するのは環境です。第3章で学ぶように、評価を行う文脈を提供する存在としての環境という一般的概念は、プログラムの実行について理解するうえで重要な役割を果たしています。 上に書いた評価規則は、定義については扱っていないということに注意してください。例えば、(define x 3)\\texttt{(define x 3)}(define x 3)を評価する際には、記号x\\texttt{x}xの値と3という二つの引数にdefine\\texttt{define}defineを適用するということはしません。define\\texttt{define}defineの目的は、まさに記号x\\texttt{x}xと値を関連づけるということだからです(つまり、(define x 3)\\texttt{(define x 3)}(define x 3)は複合式ではないということになります)。 このような、一般的評価規則に対する例外は、特殊形式(special form)と呼ばれます。ここまでの範囲では、define\\texttt{define}defineは特殊形式の唯一の例ですが、ほかのものももうすぐ見ていくことになります。それぞれの特殊形式は、固有の評価規則を持っています。それらのいろいろな種類の式(それぞれ関連づけられた評価規則を持つ)は、プログラミング言語の構文を構成します。ほかの多くのプログラミング言語と比べると、Lispはとても単純な構文を持っています。それは、式の評価規則はひとつの単純な一般規則と少数の特殊な形に対する特殊規則からなるということです。11 10. 評価規則によると、一つ目のステップの一部として、組み合わせの左端の要素を評価しなければいけないことになります。このことを奇妙に思われるかもしれません。この時点では、左端の要素というと、+\\texttt{+}+や*\\texttt{*}*といった、足し算やかけ算のような組み込みの基本的な手続きを表す演算子でしかありえないからです。のちに、演算子がそれ自身複合式であるような組み合わせを使うことが便利だということを学びます。 ↩ 11. 統一された書き方でも書けるものに対して、便利さのために別の表面構造を持たせるような特殊な構文形式は、Peter Landinの造語を使ってシンタックスシュガー(syntactic sugar)と呼ばれることがあります。ほかの言語の使用者と比べると、Lispプログラマは一般に、構文の問題をあまり気にしていません(これと対照的なのがPascalです。何でもいいのでPascalのマニュアルを開いて、どれだけのページが構文の記述に充てられているか見てみてください)。このように構文を軽視しているのは、ひとつは表面的な構文を変えやすいLispの柔軟性のためです。もうひとつは、多くの“便利な”構文構造が言語の統一性を損ない、プログラムが大きく複雑になるにつれ利点よりも欠点のほうが多くなるという観察結果のためです。Alan Perilの言葉を借りると、“シンタックスシュガーはセミコロン(コロン(直腸)とかけている)の癌を引き起こす”ということです。 ↩ "},"1.1.5_The_Substitution_Model_for_Procedure_Application.html":{"url":"1.1.5_The_Substitution_Model_for_Procedure_Application.html","title":"1.1.5 手続き適用の置換モデル","keywords":"","body":"1.1.5 手続き適用の置換モデル 演算子が複合手続きを指すような組み合わせをインタプリタが評価するとき、1.1.3節で説明したような、演算子が基本手続きを指す組み合わせを評価する場合とほぼ同じような手順をたどります。つまり、インタプリタは組み合わせの各要素を評価し、手続き(組み合わせの演算子の値)を引数(組み合わせの被演算子の値)に適用するということです。 基本手続きを引数に適用する仕組みは、インタプリタに組み込まれていると考えることができます。複合手続きについては、その適用手順は次のようになります。 複合手続きを引数に適用するには、手続きの本体に出てくる仮引数を対応する引数で置き換えて、それを評価する。 この手順の例として、次の組み合わせを評価してみましょう。 (f 5) ここで、f\\texttt{f}fは1.1.4節で定義した手続きです。 まず、f\\texttt{f}fの本体を取得することから始めます。 (sum-of-squares (+ a 1) (* a 2)) 次に、仮引数であるa\\texttt{a}aを、引数5で置き換えます。 (sum-of-squares (+ 5 1) (* 5 2)) これによって、問題は二つの被演算子とsum-of-squares\\texttt{sum-of-squares}sum-of-squaresという演算子の組み合わせの評価ということになります。この組み合わせの評価は、三つの部分問題を持っています。適用する手続きを得るためには演算子を評価する必要があり、引数を得るためには二つの被演算子を評価しなければなりません。ここで、(+ 5 1)\\texttt{(+ 5 1)}(+ 5 1)の結果は6で、(* 5 2)\\texttt{(* 5 2)}(* 5 2)の結果は10なので、sum-of-squares\\texttt{sum-of-squares}sum-of-squaresという手続きを6と10に適用することになります。これらの値によってsum-of-squares\\texttt{sum-of-squares}sum-of-squaresの本体に出てくる仮引数x\\texttt{x}xとy\\texttt{y}yを置き換えて、次の式を得ます。 (+ (square 6) (square 10)) square\\texttt{square}squareの定義を使うと、これは次の式になります。 (+ (* 6 6) (* 10 10)) かけ算によって、次のようになります。 (+ 36 100) そして、最終的には次のようになります。 136 ここまでで説明した手順は、手続き適用の置換モデル(substitution model)と呼ばれます。これは、この章に出てくる手続きに限ると、手続き適用の“意味”を決めるモデルとして捉えることができます。しかし、二つ強調しておくことがあります。 置換の目的は、手続き適用について考えやすくするためのもので、インタプリタが実際にどのように動いているかについて記述したものではありません。インタプリタは普通、手続き適用の評価にあたって、手続きのテキストを操作して仮引数を値で置き換えるということはしません。実際には、この“置換”は仮引数のために局所環境を使うことによって実現します。このことについては、第3章と第4章で、インタプリタの実装について詳しく調べながら見ていきます。 この本を通して、インタプリタの動作について、だんだん精巧になっていく一連のモデルを提示していきます。最終的には、第5章でインタプリタとコンパイラの完全な実装にまで到達します。置換モデルは、これらのモデルの最初のひとつ---評価手順について形式的に考えるための最初の一歩となるもの---に過ぎません。一般に、科学や工学で現象をモデル化するときには、単純化した不完全なモデルから始めます。物事を詳細に調べていくにつれ、これらの単純なモデルは不適切になり、より精密なモデルで置き換えなければならなくなります。置換モデルも例外ではありません。特に、第3章で“可変データ”を持つ手続きについて考える場合に、置換モデルが破綻してもっと複雑な手続き適用モデルによって置き換えなければならないことがわかります。15 適用順序と正規順序 1.1.3節での評価の記述によると、インタプリタはまず演算子と被演算子を評価し、評価結果として返される手続きを評価結果として返される引数に適用します。これは、評価を行うための唯一のやり方ではありません。考えられるほかの評価モデルとしては、値が必要になるまで被演算子を評価しないというものがあります。その代わりに、まず被演算子の式を基本演算子しか出てこない式になるまで置き換えてから評価を行います。この方法を使うと、(f 5)\\texttt{(f 5)}(f 5)の評価は次のような展開の連続によって進みます。 (sum-of-squares (+ 5 1) (* 5 2)) (+ (square (+ 5 1)) (square (* 5 2)) ) (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2))) それから、次のように簡約されます。 (+ (* 6 6) (* 10 10)) (+ 36 100) 136 この方法でも前の評価モデルと同じ値が得られますが、手順が違います。特に、こちらでは(+ 5 1)\\texttt{(+ 5 1)}(+ 5 1)と(* 5 2)\\texttt{(* 5 2)}(* 5 2)の評価がそれぞれ二回行われます。これは、式(* x x)\\texttt{(* x x)}(* x x)のx\\texttt{x}xを、それぞれ(+ 5 1)\\texttt{(+ 5 1)}(+ 5 1)と(* 5 2)\\texttt{(* 5 2)}(* 5 2)で置き換えることに対応しています。 この“完全に展開してから簡約する”というもうひとつの評価方法は、正規順序評価(normal-order evaluation)として知られています。それに対して、インタプリタが実際に使っている“引数を評価してから適用する”という方法は、適用順序評価(applicative-order evaluation)と呼ばれます。置換によってモデル化でき(この本の最初の二章の手続きはすべてそうです)、かつ正当な値を返す手続き適用については、正規順序評価と適用順序評価は同じ値になるということが証明できます(正規順序評価と適用順序評価が同じ値にならない“不当な”値の例については、練習問題 1.5を参照してください)。 Lispは適用順序評価を使っています。理由のひとつは、上で見た(+ 5 1)\\texttt{(+ 5 1)}(+ 5 1) と (* 5 2)\\texttt{(* 5 2)}(* 5 2)のような複数回の評価を避けることによる性能の向上です。そして、もっと大きな理由としては、置換によってモデル化できる手続きの範囲を超えると正規順序評価がとても複雑になるということがあります。一方で、正規順序評価は非常に価値のあるツールにもなりえます。そのことについては、第3章と第4章で一部見ていきます。16 15. 置換という考え方は単純なものですが、置換手順の厳密な数学的定義をしようとすると驚くほど複雑になるということがわかっています。この問題は、手続きの仮引数に使われる名前と、手続きを適用する式で使われている(同じである可能性のある)名前とを混同する可能性から来ています。実際に、論理学とプログラミング意味論の文献においては、置換(substitution)の間違った定義に関する長い歴史があります。置換に関する精密な考察については、Stoy 1977を参照してください。 ↩ 16. 第3章ではストリーム処理(stream processing)を導入します。これは、限定された形の正規順序評価を組み入れることで、“無限”に見えるデータ構造を扱うという手法です。4.2節では、Schemeインタプリタに手を加え、Schemeの正規順序バージョンを作成します。 ↩ "},"非公式日本語版.html":{"url":"非公式日本語版.html","title":"非公式日本語版","keywords":"","body":"非公式日本語版 SICPはかつて第一版、第二版共に日本にて公式に翻訳が商業出版されていました。第二版を出版していたピアソン桐原が2013年8月にピアソングループから撤退し技術書の取扱を終了したため、日本語でSICPを読む機会は失われました。このことがこの翻訳を行うことの契機となりました。 実際にはその後、2014年1月付近に、寛大にも第二版の訳者、和田英一先生がオンライン上にてSICPの訳書、「計算機プログラムの構造と解釈」全文を公開して下さいました。この時点でこの非公式日本語版の価値は随分と小さくなりました。 しかし、その時、既に3章まで翻訳していたこと、そして非公式TexInfo版が2013年11月に大改訂を行い、当初の日本語には正式に対応していないtexi2pdfから変更を行い、XeLaTeXを採用したために、日本語でも美しい組版ができる可能性が出てきたことが、この原稿を廃棄することを押し止めました。 SICPのライセンスについてはインターネットアーカイブにて調べてみました。2001年1月にMITがSICPを寛大にもオンラインで無料で読むことができるように公開された時にはライセンスが指定されていませんでした。 2008年4月にMITはSICPのライセンスをCC BY-NCと指定しました。その後ライセンスは2011年10月に一旦CC BY-SAに変更されます。そして2年後の2013年9月に再びCC BY-NCへと戻されました。この事実がSICP原文のライセンスの解釈を難しくしています。ライセンスの変更はオーナーの自由ですが、ライセンシーはコンテンツ取得時のライセンスを尊重すれば良いからです。 最初に非公式TexInfo版を作成したLytha Aythはライセンス指定の無いSICP公開をWeb文化に基づくものだと理解しました。次にLaTeXの組版を開発したAndres RabaはCC BY-SAに基き正式な許諾の下、PDF版を作成しました。私の翻訳はPDF版のライセンスであるCC BY-SAに従うことが求められます。しかし、現在のMITが非商業を求めていることを鑑みて、Raba氏に許可を頂いた上で非商業制約を追加したCC BY-NC-SA 3.0にてリリースすることにしました。 CC BY-NC、及びBY-SAは共に翻訳の許可を明記しています。従ってこの翻訳にはLythaが心配したような法的問題は起こらないと信じています。しかし同時に、法的問題は常に一方的に起こされることがあることもまた現実です。従って読者の皆様には常にネットワーク上のデータは(そしてプログラムも!)消えてなくなってしまうシャボン玉であることを忘れずに御用心願います。 TeX、LaTeX環境の日本語対応を進めて下さった全ての関係者の皆様に感謝します。特に最新の情報を常に更新し続けて下さっているTeX Wikiの奥村~晴彦氏、W32TeXを自動でインストールし更新可能なTeXインストーラ作者の阿部~紀行氏、XeLaTeX向け日本語パッケージ“ZXjatype”を開発して下さった八登~崇之氏に感謝致します。 海外ではSICPの新しい形の開発が非常に盛んです。PDFはもちろん、epubやインタラクティブ版、Kindle版(mobi形式)、ClojureやJavaScriptによるSICP等が公開されています。この翻訳はCC BY-NC-SAですので非商業であればそのような派生や翻案に利用することが可能です。日本でもSICPの世界が広がっていくことを期待しています。 ※ 校正御協力者様 (順不同、敬称略) Kei Shiratsuchi Kimura, Koichi のな Naoki Ainoya "},"非公式日本語版_翻訳改訂版.html":{"url":"非公式日本語版_翻訳改訂版.html","title":"非公式日本語版 翻訳改訂版","keywords":"","body":"非公式日本語版 翻訳改訂版 この翻訳改訂版は、minghai氏の非公式日本語版(以降、minghai氏版)の翻訳に不十分なところが多かったため、原著から翻訳をし直したものです。この翻訳を進めるにあたっては、minghai氏版の訳を置き換えていくというやり方で進めていきました。しかし、差分を取ればわかっていただけると思いますが、minghai氏版のテキストは痕跡をとどめていないはずです。この方式を採ったのは、主にモチベーション上の理由によるものです。もしminghai氏版の痕跡が(誰が訳しても同じようになるものを除いて)あるとすれば、それは作業漏れが残っているということですので、ご報告いただければ幸いです。 用語については、無用の混乱を避けるため、和田英一氏によるオンライン版「計算機プログラムの構造と解釈」(以下、和田氏版)にできるだけ追従するようにしました。もちろん、訳文はすべて自分で一から作り上げたものです。用語の追従によって著作権やライセンス上の問題が発生することはないと信じていますが、問題があるようであればお教えいただければと思います。 私としては、もしminghai氏版がなければ、和田氏版の訳書を購入して勉強して、それで済ませていたはずのところです。訳文は硬いとはいえ読めないことはなく、英語で読むよりは速く進められそうでした。ほかのこなれていない訳書同様、不満を持ちながら読み、それで終わりだったはずです。 しかし、minghai氏版が出てきたことで、状況は大きく変わりました。minghai氏版は無料のPDFなので、有料の書籍とオンラインHTMLという和田氏版よりアクセスが容易です。さらに、和田氏版は(Amazonのレビューにもあるように)翻訳の評判がよくありませんが、minghai氏版はですます調で一見親しみやすく、翻訳に問題が多いということがすぐにはわかりません。 これでは、SICPの評判を聞いて勉強しようとした人が、minghai氏版に流れてしまうのではないか。私のその危惧は、Twitterのタイムラインで現実化していました。タイムラインでもminghai氏版に手を伸ばそうとしている人がいたため、和田氏版をお勧めしておきました。もちろん、その人は氷山の一角で、実際には少なからぬ人たちがminghai氏版に流れたのではないかと思います。 文体が硬くて意味の取りにくい翻訳の場合、読者は何とか読み解く努力をするか、読むことをあきらめて訳者を責めるか(これはAmazonレビューで起こっていることです)のどちらかの行動を取るでしょう。後者の人に対しては(有料で購入した場合)金銭的な損害を与えているかもしれませんが、それがすべてです。どうしても読みにくければ、原文で読むことになるでしょう。いずれにせよ、翻訳が存在しなかった場合以上に悪いことにはなりません。 しかし、表面上読みやすそうな問題の多い翻訳は、はるかに大きな副作用をもたらす可能性があります。実際には誤訳のために訳文が意味不明になっているだけなのに、理解できないのは書いてある内容が難しすぎるためだ、それを理解するだけの頭脳が自分にないためだ、と読者は思い込んでしまうかもしれません。それだけはどうしても避けたいところです。 それらのことを考え合わせた結果、SICP を原文から翻訳しながら勉強していくことにしました。始めたとき、毎日一時間というペースで進めていくと決め、数日間やってみた進捗状況から翻訳が終わるまでの期間を見積もったところ、どうやら一年ぐらいかかりそうだとわかりました。一年というのは長い時間です。心がくじけそうになりつつも、ミヒャエル・エンデの「モモ」を思い出し、その日その日の分だけを考え、続けていきました。毎日夜9時からを定刻としていたため、Twitterでは「時報」と言ってくれる人もいました。 そして先日、ようやく翻訳とチェック作業が終わりました。期間は予定通り一年程度でした。勉強を兼ねての翻訳だったため、中身を理解しながら、練習問題もできるだけ(といっても、第3章の途中あたりでリタイアしましたが)解いていきました。前評判に違わず、SICPの内容はとても充実していました。翻訳前に危惧していたような、「この時間で何ができたか」と後悔するようなことにはならずにすみました。 もちろん、私のこの翻訳が完全だとは思っていません。しかし、致命的な誤訳が何百箇所もあってどこから手をつけていいかもわからないような訳文でないことは保証します。この本の内容が理解できないとすれば、それは翻訳がおかしいからではありません。もちろん、内容が難しすぎるためでも、それを理解するだけの頭脳がないためでもありません。足りないのは時間をかけた読み込みです。じっくりと一文一文の意味を考え、サンプルコードを動かし、できるだけ練習問題を解いていけば、それで十分です。この本は、読者を置き去りにしようとするような本ではありません。 最後に、日本語版のテンプレートを提供していただいたことについて、minghai氏に深く感謝します。minghai氏の日本語版テンプレートがなければ、私のTeX\\TeXTE​XやLaTeX\\LaTeXLATE​Xについての限られた知識では日本語訳を行うことはできなかったでしょう。 それでは、SICP日本語版をお楽しみください。 真鍋宏史 "}}