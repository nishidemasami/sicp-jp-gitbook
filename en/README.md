# Summary

* [Contents](SUMMARY.md)
* [Unofficial Texinfo Format](Unofficial_Texinfo_Format.md)
* [Dedication](Dedication.md)
* [Foreword](Foreword.md)
* [Preface to the Second Edition](Preface_to_the_Second_Edition.md)
* [Preface to the First Edition](Preface_to_the_First_Edition.md)
* [Acknowledgments](Acknowledgments.md)
* [1 Building Abstractions with Procedures](Building_Abstractions_with_Procedures.md)
  * [1.1 The Elements of Programming](The_Elements_of_Programming.md)
    * [1.1.1 Expressions](Expressions.md)
    * [1.1.2 Naming and the Environment](Naming_and_the_Environment.md)
    * [1.1.3 Evaluating Combinations](Evaluating_Combinations.md)
    * [1.1.4 Compound Procedures](Compound_Procedures.md)
    * [1.1.5 The Substitution Model for Procedure Application](The_Substitution_Model_for_Procedure_Application.md)
    * [1.1.6 Conditional Expressions and Predicates](Conditional_Expressions_and_Predicates.md)
    * [1.1.7 Example: Square Roots by Newton’s Method](Example_Square_Roots_by_Newtons_Method.md)
    * [1.1.8 Procedures as Black-Box Abstractions](Procedures_as_Black_Box_Abstractions.md)
  * [1.2 Procedures and the Processes They Generate](Procedures_and_the_Processes_They_Generate.md)
    * [1.2.1 Linear Recursion and Iteration](Linear_Recursion_and_Iteration.md)
    * [1.2.2 Tree Recursion](Tree_Recursion.md)
    * [1.2.3 Orders of Growth](Orders_of_Growth.md)
    * [1.2.4 Exponentiation](Exponentiation.md)
    * [1.2.5 Greatest Common Divisors](Greatest_Common_Divisors.md)
    * [1.2.6 Example: Testing for Primality](Example_Testing_for_Primality.md)
  * [1.3 Formulating Abstractions with Higher-Order Procedures](Formulating_Abstractions_with_Higher_Order_Procedures.md)
    * [1.3.1 Procedures as Arguments](Procedures_as_Arguments.md)
    * [1.3.2 Constructing Procedures Using lambda](Constructing_Procedures_Using_lambda.md)
    * [1.3.3 Procedures as General Methods](Procedures_as_General_Methods.md)
    * [1.3.4 Procedures as Returned Values](Procedures_as_Returned_Values.md)
* [2 Building Abstractions with Data](Building_Abstractions_with_Data.md)
  * [2.1 Introduction to Data Abstraction](Introduction_to_Data_Abstraction.md)
    * [2.1.1 Example: Arithmetic Operations for Rational Numbers](Example_Arithmetic_Operations_for_Rational_Numbers.md)
    * [2.1.2 Abstraction Barriers](Abstraction_Barriers.md)
    * [2.1.3 What Is Meant by Data?](What_Is_Meant_by_Data.md)
    * [2.1.4 Extended Exercise: Interval Arithmetic](Extended_Exercise_Interval_Arithmetic.md)
  * [2.2 Hierarchical Data and the Closure Property](Hierarchical_Data_and_the_Closure_Property.md)
    * [2.2.1 Representing Sequences](Representing_Sequences.md)
    * [2.2.2 Hierarchical Structures](Hierarchical_Structures.md)
    * [2.2.3 Sequences as Conventional Interfaces](Sequences_as_Conventional_Interfaces.md)
    * [2.2.4 Example: A Picture Language](Example_A_Picture_Language.md)
  * [2.3 Symbolic Data](Symbolic_Data.md)
    * [2.3.1 Quotation](Quotation.md)
    * [2.3.2 Example: Symbolic Differentiation](Example_Symbolic_Differentiation.md)
    * [2.3.3 Example: Representing Sets](Example_Representing_Sets.md)
    * [2.3.4 Example: Huffman Encoding Trees](Example_Huffman_Encoding_Trees.md)
  * [2.4 Multiple Representations for Abstract Data](Multiple_Representations_for_Abstract_Data.md)
    * [2.4.1 Representations for Complex Numbers](Representations_for_Complex_Numbers.md)
    * [2.4.2 Tagged data](Tagged_data.md)
    * [2.4.3 Data-Directed Programming and Additivity](Data_Directed_Programming_and_Additivity.md)
  * [2.5 Systems with Generic Operations](Systems_with_Generic_Operations.md)
    * [2.5.1 Generic Arithmetic Operations](Generic_Arithmetic_Operations.md)
    * [2.5.2 Combining Data of Different Types](Combining_Data_of_Different_Types.md)
    * [2.5.3 Example: Symbolic Algebra](Example_Symbolic_Algebra.md)
* [3 Modularity, Objects, and State](Modularity_Objects_and_State.md)
  * [3.1 Assignment and Local State](Assignment_and_Local_State.md)
    * [3.1.1 Local State Variables](Local_State_Variables.md)
    * [3.1.2 The Benefits of Introducing Assignment](The_Benefits_of_Introducing_Assignment.md)
    * [3.1.3 The Costs of Introducing Assignment](The_Costs_of_Introducing_Assignment.md)
  * [3.2 The Environment Model of Evaluation](The_Environment_Model_of_Evaluation.md)
    * [3.2.1 The Rules for Evaluation](The_Rules_for_Evaluation.md)
    * [3.2.2 Applying Simple Procedures](Applying_Simple_Procedures.md)
    * [3.2.3 Frames as the Repository of Local State](Frames_as_the_Repository_of_Local_State.md)
    * [3.2.4 Internal Definitions](Internal_Definitions.md)
  * [3.3 Modeling with Mutable Data](Modeling_with_Mutable_Data.md)
    * [3.3.1 Mutable List Structure](Mutable_List_Structure.md)
    * [3.3.2 Representing Queues](Representing_Queues.md)
    * [3.3.3 Representing Tables](Representing_Tables.md)
    * [3.3.4 A Simulator for Digital Circuits](A_Simulator_for_Digital_Circuits.md)
    * [3.3.5 Propagation of Constraints](Propagation_of_Constraints.md)
  * [3.4 Concurrency: Time Is of the Essence](Concurrency_Time_Is_of_the_Essence.md)
    * [3.4.1 The Nature of Time in Concurrent Systems](The_Nature_of_Time_in_Concurrent_Systems.md)
    * [3.4.2 Mechanisms for Controlling Concurrency](Mechanisms_for_Controlling_Concurrency.md)
  * [3.5 Streams](Streams.md)
    * [3.5.1 Streams Are Delayed Lists](Streams_Are_Delayed_Lists.md)
    * [3.5.2 Infinite Streams](Infinite_Streams.md)
    * [3.5.3 Exploiting the Stream Paradigm](Exploiting_the_Stream_Paradigm.md)
    * [3.5.4 Streams and Delayed Evaluation](Streams_and_Delayed_Evaluation.md)
    * [3.5.5 Modularity of Functional Programs and Modularity of Objects](Modularity_of_Functional_Programs_and_Modularity_of_Objects.md)
* [4 Metalinguistic Abstraction](Metalinguistic_Abstraction.md)
  * [4.1 The Metacircular Evaluator](The_Metacircular_Evaluator.md)
    * [4.1.1 The Core of the Evaluator](The_Core_of_the_Evaluator.md)
    * [4.1.2 Representing Expressions](Representing_Expressions.md)
    * [4.1.3 Evaluator Data Structures](Evaluator_Data_Structures.md)
    * [4.1.4 Running the Evaluator as a Program](Running_the_Evaluator_as_a_Program.md)
    * [4.1.5 Data as Programs](Data_as_Programs.md)
    * [4.1.6 Internal Definitions](Internal_Definitions.md)
    * [4.1.7 Separating Syntactic Analysis from Execution](Separating_Syntactic_Analysis_from_Execution.md)
  * [4.2 Variations on a Scheme — Lazy Evaluation](Variations_on_a_Scheme_Lazy_Evaluation.md)
    * [4.2.1 Normal Order and Applicative Order](Normal_Order_and_Applicative_Order.md)
    * [4.2.2 An Interpreter with Lazy Evaluation](An_Interpreter_with_Lazy_Evaluation.md)
    * [4.2.3 Streams as Lazy Lists](Streams_as_Lazy_Lists.md)
  * [4.3 Variations on a Scheme — Nondeterministic Computing](Variations_on_a_Scheme_Nondeterministic_Computing.md)
    * [4.3.1 Amb and Search](Amb_and_Search.md)
    * [4.3.2 Examples of Nondeterministic Programs](Examples_of_Nondeterministic_Programs.md)
    * [4.3.3 Implementing the amb Evaluator](Implementing_the_amb_Evaluator.md)
  * [4.4 Logic Programming](Logic_Programming.md)
    * [4.4.1 Deductive Information Retrieval](Deductive_Information_Retrieval.md)
    * [4.4.2 How the Query System Works](How_the_Query_System_Works.md)
    * [4.4.3 Is Logic Programming Mathematical Logic?](Is_Logic_Programming_Mathematical_Logic.md)
    * [4.4.4 Implementing the Query System](Implementing_the_Query_System.md)
      * [4.4.4.1 The Driver Loop and Instantiation](The_Driver_Loop_and_Instantiation.md)
      * [4.4.4.2 The Evaluator](The_Evaluator.md)
      * [4.4.4.3 Finding Assertions by Pattern Matching](Finding_Assertions_by_Pattern_Matching.md)
      * [4.4.4.4 Rules and Unification](Rules_and_Unification.md)
      * [4.4.4.5 Maintaining the Data Base](Maintaining_the_Data_Base.md)
      * [4.4.4.6 Stream Operations](Stream_Operations.md)
      * [4.4.4.7 Query Syntax Procedures](Query_Syntax_Procedures.md)
      * [4.4.4.8 Frames and Bindings](Frames_and_Bindings.md)
* [5 Computing with Register Machines](Computing_with_Register_Machines.md)
  * [5.1 Designing Register Machines](Designing_Register_Machines.md)
    * [5.1.1 A Language for Describing Register Machines](A_Language_for_Describing_Register_Machines.md)
    * [5.1.2 Abstraction in Machine Design](Abstraction_in_Machine_Design.md)
    * [5.1.3 Subroutines](Subroutines.md)
    * [5.1.4 Using a Stack to Implement Recursion](Using_a_Stack_to_Implement_Recursion.md)
    * [5.1.5 Instruction Summary](Instruction_Summary.md)
  * [5.2 A Register-Machine Simulator](A_Register_Machine_Simulator.md)
    * [5.2.1 The Machine Model](The_Machine_Model.md)
    * [5.2.2 The Assembler](The_Assembler.md)
    * [5.2.3 Generating Execution Procedures for Instructions](Generating_Execution_Procedures_for_Instructions.md)
    * [5.2.4 Monitoring Machine Performance](Monitoring_Machine_Performance.md)
  * [5.3 Storage Allocation and Garbage Collection](Storage_Allocation_and_Garbage_Collection.md)
    * [5.3.1 Memory as Vectors](Memory_as_Vectors.md)
    * [5.3.2 Maintaining the Illusion of Infinite Memory](Maintaining_the_Illusion_of_Infinite_Memory.md)
  * [5.4 The Explicit-Control Evaluator](The_Explicit_Control_Evaluator.md)
    * [5.4.1 The Core of the Explicit-Control Evaluator](The_Core_of_the_Explicit_Control_Evaluator.md)
    * [5.4.2 Sequence Evaluation and Tail Recursion](Sequence_Evaluation_and_Tail_Recursion.md)
    * [5.4.3 Conditionals, Assignments, and Definitions](Conditionals_Assignments_and_Definitions.md)
    * [5.4.4 Running the Evaluator](Running_the_Evaluator.md)
  * [5.5 Compilation](Compilation.md)
    * [5.5.1 Structure of the Compiler](Structure_of_the_Compiler.md)
    * [5.5.2 Compiling Expressions](Compiling_Expressions.md)
    * [5.5.3 Compiling Combinations](Compiling_Combinations.md)
    * [5.5.4 Combining Instruction Sequences](Combining_Instruction_Sequences.md)
    * [5.5.5 An Example of Compiled Code](An_Example_of_Compiled_Code.md)
    * [5.5.6 Lexical Addressing](Lexical_Addressing.md)
    * [5.5.7 Interfacing Compiled Code to the Evaluator](Interfacing_Compiled_Code_to_the_Evaluator.md)
* [References](References.md)
* [List of Exercises](List_of_Exercises.md)
* [List of Figures](List_of_Figures.md)
* [Index](Index.md)
* [Colophon](Colophon.md)